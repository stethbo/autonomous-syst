{
  "## Plik. 1": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij przeznaczenie poszczeg\u00f3lnych bit\u00f3w rejestru STATUS.": "Rejestr STATUS jest rejestrem stanu u\u017cywanym w wielu mikrokontrolerach i mikroprocesorach. Zawiera on wiele bit\u00f3w, z kt\u00f3rych ka\u017cdy pe\u0142ni okre\u015blon\u0105 rol\u0119:\n\n- bit C: przeniesienie - ustawiany wtedy, gdy poprzednia operacja matematyczna spowodowa\u0142a przeniesienie (ang. carry)\n- bit DC: po\u0142owa przeniesienia - ustawiany wtedy, gdy poprzednia operacja matematyczna spowodowa\u0142a przeniesienie w po\u0142owie warto\u015bci (ang. half-carry)\n- bit Z: zero - ustawiany wtedy, gdy wynik poprzedniej operacji matematycznej jest r\u00f3wny 0\n- bit S: znak - ustawiany wtedy, gdy wynik poprzedniej operacji matematycznej jest ujemny\n- bit P/V: parzysto\u015b\u0107/przepe\u0142nienie - u\u017cywany w niekt\u00f3rych architekturach procesor\u00f3w do sygnalizowania b\u0142\u0119du przepe\u0142nienia (ang. overflow)\n- bit N: ustawiany wtedy, gdy ostatnio wykonana operacja by\u0142a odejmowaniem (ang. subtract)\n\nDzi\u0119ki wykorzystaniu tych bit\u00f3w, mo\u017cna np. w \u0142atwy spos\u00f3b sprawdzi\u0107, czy wynik ostatniej operacji matematycznej spe\u0142nia okre\u015blone warunki, co mo\u017ce by\u0107 przydatne w wielu sytuacjach."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "Tekstu na wy\u015bwietlaczu HD44780, a tak\u017ce jakie funkcje s\u0105 dost\u0119pne dzi\u0119ki temu oprogramowaniu.\n\nWy\u015bwietlacz HD44780 to popularny rodzaj wy\u015bwietlacza alfanumerycznego opieranego na technologii LCD. Do obs\u0142ugi takiego wy\u015bwietlacza potrzebne jest oprogramowanie kontrolera, kt\u00f3ry stoi za dzia\u0142aniem tego urz\u0105dzenia. W programowaniu tego typu wy\u015bwietlaczy stosowane s\u0105 instrukcje steruj\u0105ce umo\u017cliwiaj\u0105ce kontrol\u0119 nad wy\u015bwietlanym tekstem, kursorami oraz innymi elementami interfejsu. \n\nPodstawowe instrukcje, kt\u00f3re s\u0105 niezb\u0119dne do wy\u015bwietlenia tekstu to mi\u0119dzy innymi:\n\n- Instrukcja ustawienia trybu 4-bitowego lub 8-bitowego komunikacji,\n- Instrukcja ustawienia liczby wierszy i kolumn wy\u015bwietlacza,\n- Instrukcja ustawienia trybu kursora,\n- Instrukcja w\u0142\u0105czenia i wy\u0142\u0105czenia wy\u015bwietlacza,\n- Instrukcja ustawienia po\u0142o\u017cenia kursora.\n\nDodatkowo, w oparciu o te instrukcje mo\u017cna zaimplementowa\u0107 szereg funkcji, takich jak:\n\n- Wpisywanie tekstu na wy\u015bwietlacz,\n- Przesuwanie tekstu w lewo lub w prawo,\n- W\u0142\u0105czanie i wy\u0142\u0105czanie migania kursora,\n- Zmienianie jasno\u015bci wy\u015bwietlacza.\n\nProgramowanie wy\u015bwietlacza HD44780 to proces stosunkowo prosty, jednak wymaga dobrej znajomo\u015bci instrukcji kontrolera, aby m\u00f3c tworzy\u0107 zaawansowane funkcje i interfejsy. Dzi\u0119ki w\u0142a\u015bciwemu programowaniu mo\u017cliwe jest uzyskanie wygodnego i przejrzystego interfejsu u\u017cytkownika w r\u00f3\u017cnego rodzaju urz\u0105dzeniach elektronicznych, takich jak zegarki, liczniki, kontrolery i wiele innych."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym:\n\ndy/dt = a*y + b*x\n\ngdzie:\n- y(t) jest wynikiem pomiaru czujnika w chwili t\n- x(t) jest warto\u015bci\u0105 sygna\u0142u wej\u015bciowego w chwili t\n- a, b s\u0105 sta\u0142ymi wsp\u00f3\u0142czynnikami charakteryzuj\u0105cymi czujnik\n\nR\u00f3wnanie to opisuje dynamik\u0119 czujnika, czyli spos\u00f3b w jaki reaguje on na zmiany sygna\u0142u wej\u015bciowego x(t). Im wi\u0119ksze warto\u015bci a i b, tym bardziej czu\u0142y jest czujnik na zmiany sygna\u0142u wej\u015bciowego. R\u00f3wnanie to mo\u017ce by\u0107 stosowane do modelowania r\u00f3\u017cnych typ\u00f3w czujnik\u00f3w, takich jak termometry, barometry czy akcelerometry."
      }
    ],
    "#n": 1
  },
  "## Plik. 2": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci programu w mikrokontrolerze PIC16f877A.": "Mikrokontroler PIC16f877A ma ograniczone mo\u017cliwo\u015bci adresacji pami\u0119ci w por\u00f3wnaniu do bardziej zaawansowanych mikrokontroler\u00f3w. Adresacja pami\u0119ci w tym mikrokontrolerze mo\u017ce odbywa\u0107 si\u0119 na kilka sposob\u00f3w:\n\n1. Adresowanie bezpo\u015brednie - Polega na bezpo\u015brednim odwo\u0142ywaniu si\u0119 do adresu pami\u0119ci w instrukcji. Na przyk\u0142ad, instrukcja: \"MOVWF 0x20\" przeniesie warto\u015b\u0107 rejestru roboczego do adresu 0x20 w pami\u0119ci danych.\n\n2. Adresowanie za pomoc\u0105 rejestru wskazuj\u0105cego - Wykorzystuj\u0105c rejestry wska\u017anika (W), mo\u017cna odnie\u015b\u0107 si\u0119 do jednego adresu pami\u0119ci z danymi lub instrukcji. Przyk\u0142adowo, instrukcja \"MOVWF FSR\" przenosi warto\u015b\u0107 rejestru roboczego (W) do rejestru wska\u017anika (FSR), kt\u00f3ry mo\u017ce s\u0142u\u017cy\u0107 do adresowania pami\u0119ci.\n\n3. Adresowanie za pomoc\u0105 rejestru i przesuni\u0119cia - Ten spos\u00f3b adresacji pami\u0119ci umo\u017cliwia przesy\u0142anie do pami\u0119ci adresu, kt\u00f3ry jest przesuni\u0119ciem w ramach zawarto\u015bci rejestru wska\u017anika. Przyk\u0142adowo, je\u015bli FSR ma warto\u015b\u0107 0x10, to instrukcja \"MOVWF 0x0 (FSR)\" przeniesie warto\u015b\u0107 rejestru roboczego do adresu pami\u0119ci 0x10.\n\n4. Adresowanie za pomoc\u0105 sta\u0142ej i rejestru - Zastosowanie sta\u0142ej (lub litera\u0142u) i rejestru umo\u017cliwia dost\u0119p do adresu pami\u0119ci, kt\u00f3rego warto\u015b\u0107 jest wynikiem dodania warto\u015bci rejestru roboczego do podanej sta\u0142ej. Przyk\u0142adowo, instrukcja \"MOVLW 0x0A, ADDWF 0x20,W\" pobierze warto\u015b\u0107 0x0A do rejestru roboczego, doda j\u0105 do zawarto\u015bci adresu 0x20 w pami\u0119ci danych i wynik przenosi do rejestru roboczego.\n\n5. Adresowanie za pomoc\u0105 indeksowania - Umo\u017cliwia to dost\u0119p do pami\u0119ci poprzez przypisanie do adresu pami\u0119ci warto\u015bci liczbowej lub zawarto\u015bci rejestru. Na przyk\u0142ad, instrukcja \"MOVF TBL, W, 0x1\" przeniesie warto\u015b\u0107 z tablicy pami\u0119ci o adresie TBL do rejestru roboczego (W) i inkrementuje adres TBL o 1."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy to urz\u0105dzenie, kt\u00f3re zamienia sygna\u0142 analogowy (np. d\u017awi\u0119k, obraz, temperatur\u0119) na sygna\u0142 cyfrowy, przeznaczony do przetwarzania i interpretacji przez komputer. \n\nW procesie konwersji analogowo-cyfrowej najpierw sygna\u0142 jest pr\u00f3bkowany, co oznacza, \u017ce jest on pobierany przez konwerter w r\u00f3wnych odst\u0119pach czasowych. Nast\u0119pnie, ka\u017cda pr\u00f3bka jest kwantowana, co oznacza, \u017ce jej warto\u015b\u0107 jest zaokr\u0105glana do najbli\u017cszej warto\u015bci na skali cyfrowej.\n\nWynikaj\u0105ce z tego pr\u00f3bkowanie i kwantowanie mog\u0105 prowadzi\u0107 do b\u0142\u0119d\u00f3w, zwanych b\u0142\u0119dami kwantyzacji, kt\u00f3re mog\u0105 wp\u0142yn\u0105\u0107 na jako\u015b\u0107 sygna\u0142u. Aby zmniejszy\u0107 ryzyko tych b\u0142\u0119d\u00f3w, konwertery wykorzystuj\u0105 r\u00f3\u017cne techniki, takie jak oversampling, noise shaping i filtrowanie cyfrowe.\n\nAby korzysta\u0107 z konwertera analogowo-cyfrowego, potrzebne s\u0105 instrukcje, kt\u00f3re pozwalaj\u0105 na ustawienie r\u00f3\u017cnych parametr\u00f3w konwersji, takich jak cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania i liczba bit\u00f3w na pr\u00f3bk\u0119. Nale\u017cy tak\u017ce okre\u015bli\u0107 spos\u00f3b, w jaki sygna\u0142 wej\u015bciowy jest pod\u0142\u0105czany do konwertera (np. za pomoc\u0105 interfejsu USB, portu szeregowego lub z\u0142\u0105cza Ethernet).\n\nW niekt\u00f3rych przypadkach, szczeg\u00f3lnie gdy chodzi o aplikacje specjalistyczne, mo\u017ce by\u0107 konieczne dostosowanie konfiguracji konwertera analogowo-cyfrowego do indywidualnych potrzeb u\u017cytkownika. W takim przypadku potrzebne b\u0119dzie programowanie w j\u0119zykach takich jak C, C++ lub Python."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany czujnik mo\u017ce by\u0107 opisany r\u00f3wnaniem r\u00f3\u017cniczkowym, je\u015bli jego zachowanie jest opisane przez zmiany w czasie. Przyk\u0142adowo, dany czujnik temperatury mo\u017ce by\u0107 opisany r\u00f3wnaniem r\u00f3\u017cniczkowym zwi\u0105zanym z prawem zmiany temperatury w czasie w danym punkcie. R\u00f3wnanie r\u00f3\u017cniczkowe opisuj\u0105ce zachowanie czujnika mo\u017ce mie\u0107 r\u00f3\u017cne postacie w zale\u017cno\u015bci od rodzaju czujnika i jego specyfikacji. Og\u00f3lnie, r\u00f3wnanie r\u00f3\u017cniczkowe opisuj\u0105ce zachowanie czujnika mo\u017ce by\u0107 wykorzystane do okre\u015blenia jego dok\u0142adno\u015bci, czu\u0142o\u015bci i innych parametr\u00f3w."
      }
    ],
    "#n": 2
  },
  "## Plik. 3": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci danych w mikrokontrolerze PIC16f877A.": "W mikrokontrolerze PIC16f877A, pami\u0119\u0107 danych mo\u017ce by\u0107 adresowana na kilka sposob\u00f3w:\n\n1. Adresowanie bezpo\u015brednie - adresowane s\u0105 bezpo\u015brednio rejestry, kt\u00f3re przechowuj\u0105 dane. W tym przypadku, adres rejestru wskazuje na konkretny rejestr w pami\u0119ci danych.\n\n2. Adresowanie po\u015brednie - adresowane s\u0105 rejestry wska\u017anikowe, kt\u00f3re wskazuj\u0105 na miejsce, gdzie przechowywane s\u0105 dane. W tym przypadku, nie jest konieczne podanie bezpo\u015bredniego adresu pami\u0119ci, lecz wska\u017anik wskazuje na ni\u0105.\n\n3. Adresowanie indeksowe - stosowane jest w przypadku dost\u0119pu do tablic lub struktur danych. Adres pami\u0119ci jest obliczany na podstawie warto\u015bci indeksu oraz offsetu.\n\n4. Adresowanie autoinkrementacyjne - pozwala na dynamiczne zmienianie adresu pami\u0119ci przy ka\u017cdym odwo\u0142aniu do niego. W przypadku ustawienia bitu INDF Auto-Increment (INC), adres pami\u0119ci zostaje zwi\u0119kszony o 1 po ka\u017cdym odczycie lub zapisie.\n\n5. Adresowanie bezwzgl\u0119dne - adres pami\u0119ci jest podawany wprost, bezpo\u015brednio w instrukcji. W tym przypadku, mo\u017cliwe jest odwo\u0142anie si\u0119 do dowolnego miejsca w pami\u0119ci danych."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "rezystancja \u017ar\u00f3d\u0142a sygna\u0142u. Wyst\u0119puje tutaj tak\u017ce kondensator C1 o pojemno\u015bci 100nF.\n\n Rysunek:\n                           |------Rs------+    \n                           |               |   \n                           |               C1    \n                       R1 _|_             \n                           |      \n                           |       \n                          ---              \n                           |      \n                          GND \n\nAby obliczy\u0107 impedancj\u0119 uk\u0142adu, nale\u017cy po\u0142\u0105czy\u0107 impedancje R1 oraz kondensatora C1, tworz\u0105c impedancj\u0119 Z1:\n\nZ1 = 1 / (j\u03c9C1 + 1/R1)\n\ngdzie \u03c9 to pulsacja sygna\u0142u.\n\nNast\u0119pnie dodajemy rezystancj\u0119 \u017ar\u00f3d\u0142a sygna\u0142u Rs do impedancji Z1, otrzymuj\u0105c ca\u0142kowit\u0105 impedancj\u0119 uk\u0142adu:\n\nZ = Rs + Z1\n\nNa tej podstawie mo\u017cna wyznaczy\u0107 amplitud\u0119 i faz\u0119 sygna\u0142u na ca\u0142kowitej impedancji Z."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany czujnik opisany jest r\u00f3wnaniem r\u00f3\u017cniczkowym, kt\u00f3re opisuje jego zachowanie w czasie. Jest to r\u00f3wnanie, kt\u00f3re m\u00f3wi, jak zmieniaj\u0105 si\u0119 warto\u015bci mierzonej wielko\u015bci w zale\u017cno\u015bci od czasu. R\u00f3wnanie to zazwyczaj jest zale\u017cne od wielu czynnik\u00f3w, takich jak temperatura, wilgotno\u015b\u0107 powietrza, ci\u015bnienie atmosferyczne i inne, kt\u00f3re mog\u0105 wp\u0142ywa\u0107 na wynik pomiaru. Cz\u0119sto r\u00f3wnanie to jest opisywane za pomoc\u0105 r\u00f3wnania r\u00f3\u017cniczkowego pierwszego lub drugiego stopnia, kt\u00f3re mo\u017cna rozwi\u0105za\u0107 numerycznie lub analitycznie, aby uzyska\u0107 warto\u015bci mierzonej wielko\u015bci w czasie.  Jednym z przyk\u0142ad\u00f3w czujnika opisanego r\u00f3wnaniem r\u00f3\u017cniczkowym jest czujnik temperatury, kt\u00f3rego dzia\u0142anie mo\u017cna opisa\u0107 r\u00f3wnaniem r\u00f3\u017cniczkowym pierwszego stopnia."
      }
    ],
    "#n": 3
  },
  "## Plik. 4": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz elementy pami\u0119ci programu mikrokontrolera PIC16f877A.": "Mikrokontroler PIC16f877A ma nast\u0119puj\u0105ce elementy pami\u0119ci:\n\n1. Pami\u0119\u0107 programu (flash): jest to pami\u0119\u0107, w kt\u00f3rej znajduj\u0105 si\u0119 instrukcje programu. Mo\u017ce pomie\u015bci\u0107 do 14 336 s\u0142\u00f3w (1 s\u0142owo = 14 bit\u00f3w).\n\n2. Pami\u0119\u0107 danych RAM: jest to pami\u0119\u0107, w kt\u00f3rej program przechowuje zmienne i bufory. Mo\u017ce pomie\u015bci\u0107 do 368 bajt\u00f3w.\n\n3. Pami\u0119\u0107 FIFO: jest to pami\u0119\u0107, kt\u00f3ra s\u0142u\u017cy do przechowywania danych w trybie kolejki. Jest u\u017cywana w \u0142\u0105czno\u015bci asynchronicznej i Synchronous Serial Port (SSP).\n\n4. Pami\u0119\u0107 EEPROM: jest to pami\u0119\u0107, w kt\u00f3rej program mo\u017ce przechowywa\u0107 dane trwa\u0142e. Mo\u017ce pomie\u015bci\u0107 do 256 bajt\u00f3w.\n\n5. Pami\u0119\u0107 rejestrowa: jest to zestaw specjalnych rejestr\u00f3w w mikrokontrolerze, kt\u00f3re przechowuj\u0105 stany flag, adresy, warto\u015bci i inne dane wa\u017cne dla dzia\u0142ania programu.\n\n6. Pami\u0119\u0107 stosu: jest to specjalna pami\u0119\u0107 w mikrokontrolerze, kt\u00f3ra s\u0142u\u017cy do przechowywania adres\u00f3w powrotu i danych operacyjnych w trakcie wykonywania funkcji.\n\n7. Pami\u0119\u0107 wektor\u00f3w przerwa\u0144: jest to pami\u0119\u0107, w kt\u00f3rej przechowywane s\u0105 adresy funkcji obs\u0142uguj\u0105cych przerwania."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwoma fazami aktywnymi.\n\nSilnik krokowy jest elektromechanicznym uk\u0142adem sk\u0142adaj\u0105cym si\u0119 z jednej lub kilku faz, w kt\u00f3rych przep\u0142ywa pr\u0105d zmieniaj\u0105cy kierunek w okre\u015blonych momentach, prowadz\u0105c do obracania si\u0119 wa\u0142u silnika. Spos\u00f3b dzia\u0142ania silnika krokowego zale\u017cy od trybu pracy, czyli liczby faz aktywnych.\n\nW trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105 do silnika jest podawany impuls elektryczny, kt\u00f3ry w\u0142\u0105cza jedn\u0105 faz\u0119 (np. faz\u0119 A) na zasadzie przemiany stan\u00f3w logicznych. Po pewnym czasie impuls jest zatrzymywany (stan nieaktywny). W kolejnym kroku do silnika jest podawany kolejny impuls, kt\u00f3ry w\u0142\u0105cza faz\u0119 B, a nast\u0119pnie znowu nast\u0119puje przerwa. Ten cykl jest kontynuowany, a ka\u017cda faza odpowiada za obr\u00f3t wa\u0142u silnika o okre\u015blon\u0105 warto\u015b\u0107 k\u0105ta.\n\nW trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi do silnika jest podawany impuls elektryczny, kt\u00f3ry w\u0142\u0105cza dwie fazy jednocze\u015bnie (np. fazy A i B). Te dwie fazy utworz\u0105 pole magnetyczne, kt\u00f3re przyci\u0105gnie do siebie kolejne z\u0119by wa\u0142u. Nast\u0119pnie impuls jest zatrzymywany, a na kolejnym kroku podawane s\u0105 kolejne dwie fazy (np. fazy B i C), a\u017c do obr\u00f3cenia wa\u0142u o odpowiedni\u0105 liczb\u0119 krok\u00f3w.\n\nW obu trybach pracy silnik krokowy wykonuje obr\u00f3t o okre\u015blon\u0105 warto\u015b\u0107 k\u0105ta, kt\u00f3ry zale\u017cy od liczby faz i k\u0105ta podzielonego na pe\u0142ne kroki. Przy zwi\u0119kszeniu liczby faz aktywnych nast\u0119puje zwi\u0119kszenie dok\u0142adno\u015bci obrotu. Silnik krokowy jest cz\u0119sto stosowany w urz\u0105dzeniach precyzyjnych, takich jak roboty przemys\u0142owe, drukarki, urz\u0105dzenia medyczne, itp."
      },
      {
        "Zad. 3 Wyznacz (przybli\u017con\u0105) liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, dla kt\u00f3rego zebrano do\u015bwiadczalnie": "nie nast\u0119puj\u0105ce pomiary:\n\n| Wej\u015bcie    | Wyj\u015bcie   |\n|-----------|-----------|\n| 0         | 0         |\n| 10        | 2         |\n| 20        | 4         |\n| 30        | 6         |\n| 40        | 8         |\n\nAby wyznaczy\u0107 przybli\u017con\u0105 liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika nale\u017cy skorzysta\u0107 z r\u00f3wnania prostej y = kx + b, gdzie y jest wyj\u015bciem czujnika, x jest wej\u015bciem czujnika, k jest wsp\u00f3\u0142czynnikiem kierunkowym, a b jest przesuni\u0119ciem w pionie.\n\nNajpierw nale\u017cy obliczy\u0107 warto\u015b\u0107 k:\n\nk = (y2 - y1) / (x2 - x1) = (2 - 0) / (10 - 0) = 0.2\n\nNast\u0119pnie mo\u017cna obliczy\u0107 warto\u015b\u0107 b, korzystaj\u0105c ze wzoru:\n\nb = y - kx\n\n\u015arednia warto\u015b\u0107 wyj\u015bcia dla x = 0:\n\ny_avg = (y1 + y2) / 2 = (0 + 2) / 2 = 1\n\nb = y_avg - k * x_avg = 1 - 0.2 * 5 = 0\n\nOstatecznie, liniowa charakterystyka wej\u015bciowo-wyj\u015bciowa czujnika wynosi:\n\ny = 0.2x + 0\n\nJest to r\u00f3wnanie prostej przechodz\u0105cej przez punkty (0,0) i (40,8), kt\u00f3ra reprezentuje przybli\u017con\u0105 liniow\u0105 relacj\u0119 mi\u0119dzy wej\u015bciem i wyj\u015bciem czujnika."
      }
    ],
    "#n": 4
  },
  "## Plik. 5": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz podstawowe elementy pami\u0119ci mikrokontrolera PIC16f877A.": "1. Pami\u0119\u0107 programu (FLASH) - to pami\u0119\u0107, w kt\u00f3rej przechowywany jest program zarz\u0105dzaj\u0105cy prac\u0105 mikrokontrolera. Zawiera ona instrukcje do wykonania przez procesor.\n\n2. Pami\u0119\u0107 danych SRAM - to pami\u0119\u0107, w kt\u00f3rej przechowywane s\u0105 zmienne oraz wyniki po\u015brednie oblicze\u0144.\n\n3. Pami\u0119\u0107 EEPROM - to pami\u0119\u0107 nieulotna, w kt\u00f3rej przechowywane s\u0105 dane, kt\u00f3re nie powinny by\u0107 tracone przy wy\u0142\u0105czeniu zasilania.\n\n4. Przetwornik analogowo-cyfrowy (ADC) - to uk\u0142ad umo\u017cliwiaj\u0105cy odczytanie sygna\u0142u analogowego i zamian\u0119 go na sygna\u0142 cyfrowy, kt\u00f3ry mo\u017ce by\u0107 przetwarzany przez mikrokontroler.\n\n5. Modu\u0142 licznika/odbiornika czasu (Timer/Counter) - to uk\u0142ad umo\u017cliwiaj\u0105cy pomiar czasu oraz generacj\u0119 sygna\u0142\u00f3w o okre\u015blonym czasie trwania.\n\n6. Interfejsy komunikacyjne - mikrokontroler PIC16f877A posiada wiele interfejs\u00f3w komunikacyjnych, takich jak UART, SPI czy I2C, umo\u017cliwiaj\u0105cych komunikacj\u0119 z innymi urz\u0105dzeniami.\n\n7. Wej\u015bcia/wyj\u015bcia (I/O) - mikrokontroler posiada wiele port\u00f3w wej\u015bcia/wyj\u015bcia, kt\u00f3re umo\u017cliwiaj\u0105 pod\u0142\u0105czenie r\u00f3\u017cnych urz\u0105dze\u0144 zewn\u0119trznych, takich jak przyciski, diody, czujniki, silniki itp.\n\n8. Procesor - to g\u0142\u00f3wny element mikrokontrolera, odpowiedzialny za przetwarzanie danych i wykonywanie instrukcji programu. W przypadku PIC16f877A jest to procesor RISC o taktowaniu do 20 MHz."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze p-n to po\u0142\u0105czenie dw\u00f3ch warstw p\u00f3\u0142przewodnik\u00f3w: p (z dodatnim no\u015bnikiem \u0142adunku) i n (z ujemnym no\u015bnikiem \u0142adunku) o przeciwnych \u0142adunkach i r\u00f3\u017cnych st\u0119\u017ceniach domieszkuj\u0105cych. \n\nPodczas tworzenia z\u0142\u0105cze p-n dochodzi do dyfuzji no\u015bnik\u00f3w \u0142adunku, czyli przeniku elektron\u00f3w z obszaru n do p (dziury) oraz dziur do obszaru n (elektrony). Ten proces prowadzi do zmniejszenia st\u0119\u017cenia no\u015bnik\u00f3w \u0142adunku z obu stron z\u0142\u0105cza.\n\nKiedy z\u0142\u0105cze jest ro\u017cnicowane w kierunku przewodzenia \"przodem\" (P do N), to elektrodny przycisk zostaje zaktywowany blokuj\u0105c ruch dziur i elektron\u00f3w z ka\u017cdej strony z\u0142\u0105cza. Zmniejsza to potencja\u0142 dyfuzyjny i powoduje, \u017ce obszar z\u0142\u0105cza jest obszarem o wysokiej impedancji elektrostatycznej, a przycisk ten jest oznaczany jako przycisk barierowy. \n\nPr\u0105d p\u0142yn\u0105cy przez z\u0142\u0105cze jest zwykle bardzo niewielki, a przep\u0142yw no\u015bnik\u00f3w zale\u017cy od r\u00f3\u017cnicy potencja\u0142u mi\u0119dzy obszarami p i n, a tak\u017ce od barier potencja\u0142u. W z\u0142\u0105czu w kierunku odwrotnym przep\u0142yw no\u015bnik\u00f3w jest hamowany, a zwi\u0119kszenie stosowanej si\u0142y elektromotorycznej powoduje przep\u0142yw pr\u0105du tylko pod warunkiem przekroczenia warto\u015bci napi\u0119cia zap\u0142onowego. \n\nW zwi\u0105zku z tym, zjawiska zachodz\u0105ce w z\u0142\u0105czu pn, to dyfuzja no\u015bnik\u00f3w \u0142adunku i przep\u0142yw pr\u0105du w zale\u017cno\u015bci od kierunku napi\u0119cia zasilaj\u0105cego."
      }
    ],
    "#n": 5
  },
  "## Plik. 6": {
    "q&a": [
      {
        "Zad. 1 Opisz spos\u00f3b dzia\u0142ania stosu i instrukcje wykorzystywane do jego obs\u0142ugi w mikrokontrolerach klasy PIC18fxx2 i": "Stos to struktura danych, w kt\u00f3rej elementy s\u0105 dodawane lub usuwane tylko z jednego ko\u0144ca. W mikrokontrolerach klasy PIC18fxx2 stos jest implementowany w pami\u0119ci RAM i s\u0142u\u017cy do przechowywania adres\u00f3w powrotu do wywo\u0142uj\u0105cej funkcji, warto\u015bci rejestr\u00f3w i zmiennych lokalnych.\n\nInstrukcje wykorzystywane do obs\u0142ugi stosu to:\n\n- PUSH - dodaje warto\u015b\u0107 ze wskazanego rejestru na szczyt stosu.\n- POP - usuwa warto\u015b\u0107 ze szczytu stosu i zapisuje j\u0105 do wskazanego rejestru.\n- CALL - dodaje adres powrotu na stos i przechodzi do wskazanej funkcji.\n- RET - usuwa adres powrotu ze stosu i wraca do wywo\u0142uj\u0105cej funkcji.\n\nPrzyk\u0142ad u\u017cycia stosu w programie w j\u0119zyku assembler dla mikrokontrolera PIC18fxx2:\n\nORG 0x00\nSTART:\n    CALL FUNCTION\n    ; powr\u00f3t z funkcji do START\n    RET\n\nFUNCTION:\n    ; dodanie warto\u015bci 0x05 na stos\n    MOVLW 0x05\n    PUSH WREG\n    ; dodanie warto\u015bci 0x0A na stos\n    MOVLW 0x0A\n    PUSH WREG\n    ; usuni\u0119cie warto\u015bci ze szczytu stosu i zapisanie jej do rejestru\n    POP REG1\n    ; usuni\u0119cie warto\u015bci ze szczytu stosu i zapisanie jej do rejestru\n    POP REG2\n    ; dodanie warto\u015bci z rejestru REG1 i REG2 i wynik zapisanie na stosie\n    ADDWF REG1, W\n    PUSH WREG\n    ; powr\u00f3t do START\n    RET\n\nW powy\u017cszym przyk\u0142adzie warto\u015b\u0107 0x05 jest najpierw dodawana na stos za pomoc\u0105 instrukcji PUSH, a nast\u0119pnie jest pobierana ze szczytu stosu za pomoc\u0105 instrukcji POP i zapisywana do rejestru REG1. Podobnie, warto\u015b\u0107 0x0A jest dodana na stos, pobrana ze szczytu stosu i zapisana do rejestru REG2. Nast\u0119pnie te dwie warto\u015bci s\u0105 dodawane za pomoc\u0105 instrukcji ADDWF i wynik jest zapisywany na stosie. Na koniec funkcja zwraca warto\u015b\u0107 i wraca do wywo\u0142uj\u0105cej funkcji za pomoc\u0105 instrukcji RET."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 manipulatora SCARA.": "Ruchliwo\u015b\u0107 manipulatora SCARA mo\u017cna obliczy\u0107 jako liczb\u0119 stopni swobody (DoF). Typowy manipulator SCARA ma 4 stopnie swobody, co oznacza, \u017ce \u200b\u200bma 4 niezale\u017cne ruchy lub kierunki, w kt\u00f3rych mo\u017ce porusza\u0107 narz\u0119dzie ko\u0144cowe. Te 4 stopnie swobody odpowiadaj\u0105 ruchom:\n\n1. Przesuni\u0119cie w poziomie (ruch poziomy w p\u0142aszczy\u017anie roboczej)\n2. Przesuni\u0119cie w pionie (ruch pionowy w p\u0142aszczy\u017anie roboczej)\n3. Obr\u00f3t wok\u00f3\u0142 w\u0142asnej osi w p\u0142aszczy\u017anie roboczej\n4. Obr\u00f3t wok\u00f3\u0142 osi pionowej mocowania podstawy (je\u015bli manipulator ma tak\u0105 funkcjonalno\u015b\u0107)\n\nWarto jednak zaznaczy\u0107, \u017ce w zale\u017cno\u015bci od konstrukcji manipulatora, liczba stopni swobody mo\u017ce by\u0107 r\u00f3\u017cna."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie": "Zadanie kinematyki polega na wyznaczeniu po\u0142o\u017cenia ko\u0144cowego manipulatora w zale\u017cno\u015bci od k\u0105ta obrotu \u0142\u0105cza. Zatem, aby rozwi\u0105za\u0107 to zadanie, nale\u017cy przeprowadzi\u0107 kilka krok\u00f3w:\n\n1. Zdefiniuj uk\u0142ad wsp\u00f3\u0142rz\u0119dnych \u2013 w tym przypadku mo\u017cna przyj\u0105\u0107 uk\u0142ad kartezja\u0144ski, w kt\u00f3rym pocz\u0105tek uk\u0142adu znajduje si\u0119 w punkcie podstawy manipulatora, a o\u015b X ukierunkowana jest wzd\u0142u\u017c \u0142\u0105cza obrotowego.\n\n2. Narysuj schemat manipulatora \u2013 w tym przypadku b\u0119dzie to jedno \u0142\u0105cze obrotowe, zamocowane na bazie.\n\n3. Wyznacz macierz przekszta\u0142cenia \u2013 w celu wyznaczenia po\u0142o\u017cenia ko\u0144cowego manipulatora w zale\u017cno\u015bci od k\u0105ta obrotu nale\u017cy wyznaczy\u0107 macierz przekszta\u0142cenia odwzorowuj\u0105c\u0105 ruch \u0142\u0105cza obrotowego. Poniewa\u017c mamy do czynienia z jednym \u0142\u0105czem, a o\u015b obrotu jest jednocze\u015bnie osi\u0105 X uk\u0142adu wsp\u00f3\u0142rz\u0119dnych, macierz przekszta\u0142cenia przyjmuje posta\u0107:\n\nT = [cos \u03b8 -sin \u03b8 0 0;\nsin \u03b8 cos \u03b8 0 0;\n0 0 1 l 0;\n0 0 0 1 0]\n\ngdzie \u03b8 to k\u0105t obrotu \u0142\u0105cza, l to d\u0142ugo\u015b\u0107 \u0142\u0105cza, a 0 to warto\u015b\u0107 dla pozosta\u0142ych wsp\u00f3\u0142rz\u0119dnych.\n\n4. Wykonaj operacje na macierzy \u2013 aby uzyska\u0107 po\u0142o\u017cenie ko\u0144cowe manipulatora wystarczy pomno\u017cy\u0107 macierz przekszta\u0142cenia przez wektor po\u0142o\u017cenia pocz\u0105tkowego ko\u0144ca manipulatora (dla \u03b8=0) i wykona\u0107 odpowiednie operacje na wynikowej macierzy. W ko\u0144cowym wyniku, wsp\u00f3\u0142rz\u0119dne x, y i z okre\u015blaj\u0105 po\u0142o\u017cenie ko\u0144cowe manipulatora.\n\nPrzyk\u0142adowo, je\u015bli d\u0142ugo\u015b\u0107 \u0142\u0105cza wynosi l=1, a k\u0105t obrotu \u03b8=45\u00b0, to po wykonaniu powy\u017cszych krok\u00f3w, mo\u017cna otrzyma\u0107, \u017ce po\u0142o\u017cenie ko\u0144cowe manipulatora wynosi:\n\nx = 0.707; y = 0.707; z = 1.\n\nOznacza to, \u017ce ko\u0144cowy punkt manipulatora znajduje si\u0119 w odleg\u0142o\u015bci pierwiastka kwadratowego z 2 od pocz\u0105tku uk\u0142adu wsp\u00f3\u0142rz\u0119dnych w kierunku X i Y oraz na wysoko\u015bci 1 od p\u0142aszczyzny X-Y."
      }
    ],
    "#n": 6
  },
  "## Plik. 7": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij znaczenie \ufb02ag kon\ufb01guracji w mikrokontrolerze PIC16f877A": "Flagi konfiguracji w mikrokontrolerze PIC16f877A to specjalne bity, kt\u00f3re umo\u017cliwiaj\u0105 ustawienie r\u00f3\u017cnych tryb\u00f3w pracy mikrokontrolera. Flagi te kontroluj\u0105 podstawowe funkcje takie jak w\u0142\u0105czanie i wy\u0142\u0105czanie przerwa\u0144, tryby konwersji A/D, ustawianie pr\u0119dko\u015bci zegara procesora, tryby programowania i wiele innych. Ustawienie odpowiednich flag konfiguracji jest wa\u017cnym etapem projektowania uk\u0142ad\u00f3w opartych na mikrokontrolerze, poniewa\u017c ma to wp\u0142yw na wydajno\u015b\u0107 i funkcjonalno\u015b\u0107 ca\u0142ej aplikacji."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 (typowego) manipulatora ramieniowego.": "Ruchliwo\u015b\u0107 manipulatora ramieniowego zale\u017cy od liczby stopni swobody. Standardowy manipulator ramieniowy ma 6 stopni swobody, co oznacza, \u017ce mo\u017ce si\u0119 porusza\u0107 w 6 r\u00f3\u017cnych kierunkach. Jest to najbardziej popularny typ manipulatora w przemy\u015ble, poniewa\u017c zapewnia du\u017c\u0105 precyzj\u0119 i elastyczno\u015b\u0107 w wykonywaniu r\u00f3\u017cnych zada\u0144."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na": "wirniku silnika.\n\nNie zosta\u0142o podane warunk\u00f3w pocz\u0105tkowych, dlatego ci\u0119\u017cko jest dok\u0142adnie rozwi\u0105za\u0107 to zadanie, ale przyjmuj\u0105c pewne za\u0142o\u017cenia mo\u017cemy przedstawi\u0107 przyk\u0142adowe rozwi\u0105zanie.\n\nZa\u0142\u00f3\u017cmy, \u017ce manipulator zaczyna ruch w pozycji pionowej, a jego cel to obr\u00f3cenie si\u0119 wok\u00f3\u0142 osi pionowej o k\u0105t 45 stopni. D\u0142ugo\u015b\u0107 \u0142\u0105cza pryzmatycznego wynosi 1 metr, a wirnik silnika obraca si\u0119 z pr\u0119dko\u015bci\u0105 1000 obr./min.\n\nW celu wykonania tego zadania musimy zna\u0107 r\u00f3wnania kinematyki manipulatora. Jednym z najwa\u017cniejszych jest r\u00f3wnanie przemieszczenia, kt\u00f3re wyra\u017ca si\u0119 wzorem:\n\ns = r\u0394\u03c6\n\ngdzie:\n- s oznacza przemieszczenie (w metrach)\n- r to promie\u0144 okr\u0119gu, po kt\u00f3rym porusza si\u0119 manipulator (w metrach)\n- \u0394\u03c6 to k\u0105t obrotu (w radianach)\n\nZ tego wzoru wynika, \u017ce im wi\u0119kszy promie\u0144 okr\u0119gu, po kt\u00f3rym porusza si\u0119 manipulator, tym mniejszy musi by\u0107 jego k\u0105t obrotu, aby osi\u0105gn\u0105\u0107 zadane przemieszczenie.\n\nW naszym przyk\u0142adzie manipulator porusza si\u0119 po okr\u0119gu o promieniu 1 metra, dlatego dla obrotu o 45 stopni (czyli \u0394\u03c6 = \u03c0/4 rad) przemieszczenie wyniesie:\n\ns = 1 * \u03c0/4 = 0,7854 metra\n\nKolejnym r\u00f3wnaniem kinematycznym, kt\u00f3re musimy zna\u0107, jest wz\u00f3r na pr\u0119dko\u015b\u0107 liniow\u0105, wyra\u017caj\u0105cy pr\u0119dko\u015b\u0107, z jak\u0105 porusza si\u0119 manipulator. W przypadku manipulatora z jednym \u0142\u0105czem pryzmatycznym mo\u017cna to przedstawi\u0107 w nast\u0119puj\u0105cy spos\u00f3b:\n\nv = r\u03c9\n\ngdzie:\n- v to pr\u0119dko\u015b\u0107 liniowa (w metrach na sekund\u0119)\n- r to promie\u0144 okr\u0119gu, po kt\u00f3rym porusza si\u0119 manipulator (w metrach)\n- \u03c9 to pr\u0119dko\u015b\u0107 k\u0105towa (w radianach na sekund\u0119)\n\nW naszym przypadku, zak\u0142adaj\u0105c pr\u0119dko\u015b\u0107 k\u0105tow\u0105 wirnika silnika na poziomie 1000 obr./min (czyli \u03c9 = 104,72 rad/s), pr\u0119dko\u015b\u0107 liniowa wyniesie:\n\nv = 1 * 104,72 = 104,72 m/s\n\nJest to do\u015b\u0107 du\u017ca pr\u0119dko\u015b\u0107, dlatego przed rozpocz\u0119ciem ruchu bardzo wa\u017cne jest zadbanie o bezpiecze\u0144stwo pracy manipulatora oraz otoczenia, w kt\u00f3rym si\u0119 znajduje."
      }
    ],
    "#n": 7
  },
  "## Plik. 8": {
    "q&a": [
      {
        "Zad. 1 Czym jest histereza w uk\u0142adach wej\u015bciowo-wyj\u015bciowych.": "Histereza w uk\u0142adach wej\u015bciowo-wyj\u015bciowych to zjawisko, w kt\u00f3rym warto\u015b\u0107 wyj\u015bciowa nie zale\u017cy tylko od warto\u015bci wej\u015bciowej w danym momencie, ale r\u00f3wnie\u017c od historii zmian warto\u015bci wej\u015bciowej. Innymi s\u0142owy, histereza wyst\u0119puje, gdy zmiana warto\u015bci wej\u015bciowej nie powoduje natychmiastowej i dok\u0142adnej zmiany warto\u015bci wyj\u015bciowej, ale na wp\u0142ywaj\u0105 na ni\u0105 zmiany wykonywane wcze\u015bniej. Jest to zjawisko powszechne w wielu uk\u0142adach mechanicznych, elektrycznych i steruj\u0105cych. Przyk\u0142adem histerezy mo\u017ce by\u0107 sytuacja, w kt\u00f3rej d\u017awignia urz\u0105dzenia pozostanie w pozycji otwartej, nawet gdy warto\u015b\u0107 wej\u015bciowa si\u0119 zmieni\u0142a, a dopiero gdy ta warto\u015b\u0107 zostanie zmieniona o wiele wi\u0119ksz\u0105 ilo\u015b\u0107, d\u017awignia zacznie si\u0119 porusza\u0107."
      },
      {
        "Zad. 2 Wykonaj obr\u00f3t punktu [1,1,1]o30\u25e6dooko\u0142a wektora [0.5,0.4,0.3]. Zamie\u015b\u0107 odpowiednie obliczenia.": "Najpierw obliczamy d\u0142ugo\u015b\u0107 wektora [0.5, 0.4, 0.3]:\n\nsqrt(0.5^2 + 0.4^2 + 0.3^2) \u2248 0.745\n\nNast\u0119pnie normalizujemy ten wektor, czyli dzielimy jego sk\u0142adowe przez jego d\u0142ugo\u015b\u0107:\n\n[0.5/0.745, 0.4/0.745, 0.3/0.745] \u2248 [0.671, 0.536, 0.402]\n\nMamy teraz wektor jednostkowy, kt\u00f3ry pos\u0142u\u017cy nam jako o\u015b obrotu.\n\nAby wykona\u0107 obr\u00f3t punktu [1, 1, 1] o 30 stopni wok\u00f3\u0142 tego wektora, mo\u017cemy u\u017cy\u0107 wzoru:\n\np' = cos(\u03b8) * p + sin(\u03b8) * (k x p) + (1 - cos(\u03b8)) * (k * p) * k\n\ngdzie:\n- p to punkt, kt\u00f3ry obracamy\n- p' to wynikowy punkt po obr\u00f3ceniu\n- \u03b8 to k\u0105t obrotu (30 stopni w tym przypadku)\n- k to wektor jednostkowy, okre\u015blaj\u0105cy o\u015b obrotu\n\nPierwsz\u0105 operacj\u0105, jak\u0105 musimy wykona\u0107, jest produkt wektorowy k x p. Mo\u017cemy to zrobi\u0107 nast\u0119puj\u0105co:\n\n[0.671, 0.536, 0.402] x [1, 1, 1] =\n[0.536 - 0.402, -0.402 + 0.402, 0.402 - 0.536] =\n[0.134, 0, -0.134]\n\nTeraz mo\u017cemy obliczy\u0107 kolejne sk\u0142adowe wzoru:\n\ncos(30) \u2248 0.866\nsin(30) \u2248 0.5\n\nk x p = [0.134, 0, -0.134]\nsin(\u03b8) * (k x p) = [0.067, 0, -0.067]\n(k * p) * k = [0.536, 0.536, 0.402] * 0.671 \u2248 [0.359, 0.359, 0.269]\n(1 - cos(\u03b8)) * (k * p) * k = (1 - 0.866) * [0.359, 0.359, 0.269] \u2248 [0.049, 0.049, 0.037]\n\nOstatecznie, podstawiaj\u0105c wszystkie warto\u015bci do wzoru, otrzymujemy:\n\n[1, 1, 1] -> [1.438, 1.276, 0.865]\n\nNowy punkt to [1.438, 1.276, 0.865]."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105-": "czonego z ko\u0144c\u00f3wk\u0105, kt\u00f3ra porusza si\u0119 translacyjnie wzd\u0142u\u017c osi \u0142\u0105cza.\n\nZa\u0142\u00f3\u017cmy, \u017ce:\n- d\u0142ugo\u015b\u0107 \u0142\u0105cza obrotowego to L\n- odleg\u0142o\u015b\u0107 pomi\u0119dzy osi\u0105 obrotu bazy a osi\u0105 obrotu \u0142\u0105cza to a\n- odleg\u0142o\u015b\u0107 pomi\u0119dzy osi\u0105 obrotu \u0142\u0105cza a osi\u0105 translacji ko\u0144c\u00f3wki to d\n- k\u0105t obrotu \u0142\u0105cza to q\n\nZdefiniujmy tak\u017ce ramiona jako R1, R2, R3 i R4, kolejno od bazy do \u0142\u0105cza, od \u0142\u0105cza do osi translacji ko\u0144c\u00f3wki, od osi translacji do punktu chwytu oraz od punktu chwytu do ko\u0144c\u00f3wki.\n\nZaczynaj\u0105c od bazy, parametry DH to:\n- R0: a=0, d=0, q=0, alpha=0 (bazowy uk\u0142ad wsp\u00f3\u0142rz\u0119dnych, osie zgodne z uk\u0142adem \u015bwiata)\n\nPrzechodz\u0105c do \u0142\u0105cza, parametry DH to:\n- R1: a=0, d=0, q=q, alpha=-pi/2 (obrotowe po\u0142\u0105czenie ze zmieniaj\u0105cym si\u0119 k\u0105tem, osie x i y obr\u00f3cone o -pi/2 wzgl\u0119dem uk\u0142adu bazy)\n\nPrzechodz\u0105c do osi translacji ko\u0144c\u00f3wki, parametry DH to:\n- R2: a=L, d=0, q=0, alpha=pi/2 (przesuwny po\u0142\u0105czenie ze sta\u0142ym k\u0105tem 0, osie y i z obr\u00f3cone o pi/2 wzgl\u0119dem uk\u0142adu \u0142\u0105cza)\n\nPrzechodz\u0105c do punktu chwytu, parametry DH to:\n- R3: a=0, d=d, q=0, alpha=-pi/2 (przesuwny po\u0142\u0105czenie ze sta\u0142ym k\u0105tem 0, osie x i y obr\u00f3cone o -pi/2 wzgl\u0119dem uk\u0142adu translacji)\n\nPrzechodz\u0105c na ko\u0144c\u00f3wk\u0119, parametry DH to:\n- R4: a=0, d=0, q=0, alpha=0 (zwyczajne po\u0142\u0105czenie, osie zgodne z uk\u0142adem \u015bwiata)\n\nOstatecznie, zestawienie parametr\u00f3w DH dla manipulatora opisanego powy\u017cej wygl\u0105da nast\u0119puj\u0105co:\n- R0: a=0, d=0, q=0, alpha=0\n- R1: a=0, d=0, q=q, alpha=-pi/2\n- R2: a=L, d=0, q=0, alpha=pi/2\n- R3: a=0, d=d, q=0, alpha=-pi/2\n- R4: a=0, d=0, q=0, alpha=0"
      }
    ],
    "#n": 8
  },
  "## Plik. 9": {
    "q&a": [
      {
        "Zad. 1 W jaki spos\u00f3b zjawisko piezoelektryczne jest wykorzystywane do budowy mikrofon\u00f3w.": "Zjawisko piezoelektryczne jest wykorzystywane do budowy mikrofon\u00f3w poprzez wykorzystanie specjalnych kryszta\u0142\u00f3w piezoelektrycznych, takich jak kwarc czy turmalin. Kryszta\u0142 taki jest umieszczany w mikrofonie i poddawany wibracjom wywo\u0142anym przez d\u017awi\u0119ki, kt\u00f3re maj\u0105 zosta\u0107 zarejestrowane. Wibracje te wp\u0142ywaj\u0105 na kryszta\u0142 piezoelektryczny, kt\u00f3ry generuje na swoich ko\u0144cach napi\u0119cie elektryczne proporcjonalne do si\u0142y tych wibracji. Napi\u0119cie to jest nast\u0119pnie wzmacniane i przetwarzane w sygna\u0142 d\u017awi\u0119kowy, kt\u00f3ry mo\u017ce by\u0107 zapisany lub przes\u0142any na dalsze urz\u0105dzenia. Dzi\u0119ki temu w\u0142a\u015bnie zjawisku piezoelektrycznemu mo\u017cliwe jest nagrywanie d\u017awi\u0119k\u00f3w i g\u0142os\u00f3w oraz ich przekazywanie za pomoc\u0105 mikrofon\u00f3w."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "Tekstu na wy\u015bwietlaczu HD44780 mo\u017cna programowa\u0107 za pomoc\u0105 kontrolera mikroprocesora. Ten kontroler HD44780 jest stosowany w wi\u0119kszo\u015bci sterownik\u00f3w wy\u015bwietlaczy LCD. Wykorzystuje on interfejs r\u00f3wnoleg\u0142y do komunikacji z mikrokontrolerem i umo\u017cliwia sterowanie wy\u015bwietlaczem poprzez komunikacj\u0119 jednokierunkow\u0105.\n\nAby wy\u015bwietli\u0107 tekst na wy\u015bwietlaczu HD44780, nale\u017cy najpierw zainicjowa\u0107 urz\u0105dzenie. Inicjalizacja sk\u0142ada si\u0119 z napisania kilku instrukcji, kt\u00f3re ustawiaj\u0105 parametry wy\u015bwietlacza, takie jak liczba wierszy, tryb kursu lub tryb adresowania. Instrukcje te s\u0105 wysy\u0142ane z mikrokontrolera na kontroler urz\u0105dzenia poprzez 8-bitow\u0105 szyn\u0119 danych i 3 przewody steruj\u0105ce.\n\nPo zainicjowaniu wy\u015bwietlacza, mo\u017cemy wy\u015bwietli\u0107 tekst korzystaj\u0105c z nast\u0119puj\u0105cych instrukcji:\n\n1. CGRAM (Character Generator RAM) \u2013 u\u017cywane do zapisania niestandardowych znak\u00f3w\n\n2. DDRAM (Display Data RAM) \u2013 u\u017cywane do wy\u015bwietlania tekstu na ekranie\n\nNast\u0119pnie, musimy ustawi\u0107 pozycj\u0119 kursora, aby wiedzie\u0107, gdzie umie\u015bci\u0107 tekst. Ustawienie pozycji kursora odbywa si\u0119 za pomoc\u0105 instrukcji DDRAM, kt\u00f3ra umieszcza kursor w okre\u015blonym miejscu.\n\nOto przyk\u0142adowy kod programowania wy\u015bwietlacza HD44780 w j\u0119zyku C:\n\n#include \"lcd.h\" // plik nag\u0142\u00f3wkowy dla obs\u0142ugi wy\u015bwietlacza\n\nint main(void)\n{\n LCD_init(); // inicjalizacja wy\u015bwietlacza\n LCD_puts(\"Hello World!\"); // wy\u015bwietla tekst \"Hello World!\" na ekranie\n while(1);\n\n return 0;\n}\n\nW tym przyk\u0142adzie \"LCD_init()\" jest funkcj\u0105 inicjalizacyjn\u0105, a \"LCD_puts()\" wy\u015bwietla tekst na ekranie. Ca\u0142y program jest niesko\u0144czon\u0105 p\u0119tl\u0105 kontroln\u0105, kt\u00f3ra zapobiega zako\u0144czeniu dzia\u0142ania programu."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na bazie i": "posiadaj\u0105cego jeden przegub obrotowy na ko\u0144cu \u0142\u0105cza.\n\nParametry DH mo\u017cna wyznaczy\u0107 wed\u0142ug nast\u0119puj\u0105cych krok\u00f3w:\n\nKrok 1: Oznaczenie osi i przegub\u00f3w robota.\n\nPrzyjmujemy, \u017ce osie robota uk\u0142adu wsp\u00f3\u0142rz\u0119dnych s\u0105 takie same jak osie DH:\n\n    * o\u015b z przegubu 1 (baza) - osia z\n    * o\u015b z przegubu 2 (obrotowy) - osia x\n\nKrok 2: Okre\u015blenie zmiennych DH.\n\nW przypadku manipulatora z jednym \u0142\u0105czem potrzebujemy czterech zmiennych DH:\n\n    * d - odleg\u0142o\u015b\u0107 mi\u0119dzy osiami z i x, jest r\u00f3wna d\u0142ugo\u015bci \u0142\u0105cza\n    * $\\theta$ - k\u0105t pomi\u0119dzy osi\u0105 z a osi\u0105 x, jest to k\u0105t obrotu przegubu 2\n    * a - odleg\u0142o\u015b\u0107 mi\u0119dzy osiami x i y, jest r\u00f3wna 0 dla tego manipulatora\n    * $\\alpha$ - k\u0105t pomi\u0119dzy osi\u0105 x a osi\u0105 y, jest r\u00f3wny 0 dla tego manipulatora\n\nKrok 3: Okre\u015blenie macierzy transformacji.\n\nAby okre\u015bli\u0107 macierz transformacji z jednego uk\u0142adu wsp\u00f3\u0142rz\u0119dnych do drugiego, trzeba wzi\u0105\u0107 pod uwag\u0119 warto\u015bci zmiennych DH. W tym przypadku macierz transformacji wygl\u0105da nast\u0119puj\u0105co:\n\nc$\\theta$ -s$\\theta$ 0 0\n\ns$\\theta$ c$\\theta$ 0 0\n\n0 0 1 d\n\n0 0 0 1\n\ngdzie c$\\theta$ oznacza cos($\\theta$), a s$\\theta$ oznacza sin($\\theta$).\n\nKrok 4: Wyznaczanie parametr\u00f3w DH.\n\nNa podstawie macierzy transformacji mo\u017cna wyznaczy\u0107 zmiennych DH:\n\n    * $d$ - odleg\u0142o\u015b\u0107 mi\u0119dzy osiami z i x, jest r\u00f3wna warto\u015bci $d_{4,3}$ = d = \u0142\u0105cze\n    * $\\theta$ - k\u0105t obrotu przegubu 2, jest r\u00f3wny warto\u015bci atan2($a_{3,2}$, $a_{3,1}$) = atan2(0,1) = 0\n    * $a$ - odleg\u0142o\u015b\u0107 mi\u0119dzy osiami x i y, jest r\u00f3wna warto\u015bci $a_{1,2}$ = a = 0\n    * $\\alpha$ - k\u0105t pomi\u0119dzy osi\u0105 x a osi\u0105 y, jest r\u00f3wny warto\u015bci atan2($a_{2,3}$, $a_{1,3}$) = atan2(sin($\\theta$), cos($\\theta$)) = $\\theta$\n\nZatem parametry DH dla tego manipulatora to:\n\n    * $d$ = \u0142\u0105cze\n    * $\\theta$ = 0\n    * $a$ = 0\n    * $\\alpha$ = $\\theta$ = 0\n\nOstatecznie, macierz transformacji dla tego manipulatora ma posta\u0107:\n\n1 0 0 0\n\n0 1 0 0\n\n0 0 1 d\n\n0 0 0 1"
      }
    ],
    "#n": 9
  },
  "## Plik. 10": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania termopary i \u0142a\u0144cucha termicznego.": "Termopary to urz\u0105dzenia pomiarowe, kt\u00f3re wykorzystuj\u0105 zjawisko Seebecka do pomiaru temperatury. Zjawisko to polega na powstawaniu si\u0142y elektromotorycznej w przewodniku, gdy r\u00f3\u017cnica temperatur jest mi\u0119dzy jego dwoma ko\u0144cami. W termoparze sk\u0142adaj\u0105cym si\u0119 z dw\u00f3ch r\u00f3\u017cnych metali, powstaj\u0105ce si\u0142y elektromotoryczne s\u0105 proporcjonalne do r\u00f3\u017cnicy temperatur mi\u0119dzy ko\u0144cami. Ta r\u00f3\u017cnica napi\u0119cia jest mierzona i przeliczana na temperatur\u0119 za pomoc\u0105 tabel termostatycznych.\n\n\u0141a\u0144cuch termiczny to system lub proces transportu energii cieplnej z jednego punktu do drugiego, wykorzystuj\u0105cy r\u00f3\u017cne elementy termiczne, takie jak termopary, termometry oporowe czy czujniki temperatury typu RTD. Proces ten wymaga przesy\u0142ania energii cieplnej z miejsca o wy\u017cszej temperaturze do miejsca o ni\u017cszej temperaturze. W \u0142a\u0144cuchu termicznym wa\u017cne jest wyznaczenie strumienia ciep\u0142a mi\u0119dzy \u017ar\u00f3d\u0142em a odbiornikiem, jak r\u00f3wnie\u017c pr\u0119dko\u015b\u0107 przep\u0142ywu ciep\u0142a przez poszczeg\u00f3lne elementy termiczne. Wykorzystanie \u0142a\u0144cucha termicznego jest niezwykle istotne w przemy\u015ble, zw\u0142aszcza w procesach produkcyjnych, gdzie kontrola temperatur jest kluczowa dla zachowania jako\u015bci produkt\u00f3w i proces\u00f3w produkcyjnych."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy (ADC) to urz\u0105dzenie, kt\u00f3re przetwarza sygna\u0142 analogowy (np. napi\u0119cie) na sygna\u0142 cyfrowy (binarny). Istniej\u0105 r\u00f3\u017cne sposoby dzia\u0142ania, ale najcz\u0119\u015bciej stosowane to metoda aproksymacji oraz metoda sukcesywnego przybli\u017cania.\n\nMetoda aproksymacji dzia\u0142a na zasadzie por\u00f3wnywania napi\u0119cia wej\u015bciowego z pewnym napi\u0119ciem odniesienia i stopniowym zmniejszaniu przedzia\u0142u, w kt\u00f3rym mo\u017ce znajdowa\u0107 si\u0119 wej\u015bciowe napi\u0119cie. Wynikowy sygna\u0142 cyfrowy odpowiada numerowi kroku, w kt\u00f3rym napi\u0119cie zosta\u0142o odnalezione.\n\nMetoda sukcesywnego przybli\u017cania dzia\u0142a na podobnej zasadzie, ale zamiast zmniejszania przedzia\u0142u, wykorzystuje stopniowe dodawanie lub odejmowanie napi\u0119cia odniesienia, a\u017c do momentu, gdy zostanie osi\u0105gni\u0119ty sygna\u0142 wej\u015bciowy. Wynikowa liczba cyfrowa reprezentuje ilo\u015b\u0107 krok\u00f3w, potrzebnych do osi\u0105gni\u0119cia sygna\u0142u wej\u015bciowego.\n\nDo wykonania konwersji analogowo-cyfrowej, musimy wykona\u0107 kilka instrukcji:\n\n1. Konfiguracja ADC - ustawienie parametr\u00f3w pracy, takich jak pr\u0119dko\u015b\u0107 konwersji oraz poziom odniesienia.\n\n2. Inicjalizacja ADC - uruchomienie konwertera oraz przygotowanie do pracy.\n\n3. Start konwersji - pobranie pr\u00f3bki sygna\u0142u analogowego i przekazanie jej do konwertera.\n\n4. Odczyt wyniku - otrzymanie liczby cyfrowej (np. w postaci rejestru) reprezentuj\u0105cej sygna\u0142 analogowy.\n\nW zale\u017cno\u015bci od potrzeb, konwersja mo\u017ce by\u0107 wykonywana jednorazowo lub w trybie ci\u0105g\u0142ym. W przypadku pracy w trybie ci\u0105g\u0142ym, konwersja jest wykonywana automatycznie dla kolejnych pr\u00f3bek sygna\u0142u."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": ":\n\n$\\frac{dx}{dt} = kx$\n\ngdzie:\n\n$x$ - warto\u015b\u0107 mierzona przez czujnik,\n\n$t$ - czas,\n\n$k$ - sta\u0142a proporcjonalno\u015bci.\n\nR\u00f3wnanie to opisuje proces, w kt\u00f3rym warto\u015b\u0107 mierzonej przez czujnik wielko\u015bci zmienia si\u0119 proporcjonalnie do jej aktualnej warto\u015bci. Sta\u0142a $k$ okre\u015bla szybko\u015b\u0107 zmian warto\u015bci mierzonej przez czujnik. Im wi\u0119ksza warto\u015b\u0107 $k$, tym szybciej warto\u015b\u0107 mierzona b\u0119dzie si\u0119 zmniejsza\u0107 lub zwi\u0119ksza\u0107."
      }
    ],
    "#n": 10
  },
  "## Plik. 11": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania kamery CCD.": "Kamera CCD (Charge-Coupled Device) sk\u0142ada si\u0119 z matrycy setek tysi\u0119cy lub milion\u00f3w pikseli, z kt\u00f3rych ka\u017cdy rejestruje intensywno\u015b\u0107 \u015bwiat\u0142a padaj\u0105cego na niego. Piksele te s\u0105 z\u0142o\u017cone z p\u00f3l p\u00f3\u0142przewodnik\u00f3w, kt\u00f3re przechowuj\u0105 \u0142adunki elektryczne w spos\u00f3b proporcjonalny do ilo\u015bci \u015bwiat\u0142a padaj\u0105cego na nie.\n\nW momencie gdy \u015bwiat\u0142o pada na piksel, elektrony przenosz\u0105 si\u0119 z pola p\u00f3\u0142przewodnikowego w kierunku elektrody zasilaj\u0105cej dzi\u0119ki efektowi fotoelektrycznemu. Nast\u0119pnie, \u0142adunki s\u0105 przesuwane przez uk\u0142ad poziomych i pionowych przewod\u00f3w, tak zwany uk\u0142ad sterowania odczytem (ang. readout register), do specjalnego uk\u0142adu analogowo-cyfrowego konwertera (ang. ADC - Analog-to-Digital Converter), kt\u00f3ry t\u0142umaczy sygna\u0142 analogowy na cyfrowy.\n\nIstniej\u0105 r\u00f3\u017cne sposoby organizacji przewod\u00f3w uk\u0142adu sterowania odczytem, ale najcz\u0119\u015bciej stosowanymi s\u0105 architektury \"frame transfer\" i \"interline transfer\". W przypadku pierwszej, sk\u0142adaj\u0105cej si\u0119 z dw\u00f3ch matryc CCD, jedna matryca zajmuje si\u0119 zbieraniem na\u015bwietlonego obrazu, podczas gdy druga jest u\u017cywana do realizacji przetwarzania obrazu. W drugim przypadku przewody uk\u0142adu sterowania odczytem s\u0105 zamontowane wewn\u0105trz pikseli, dzi\u0119ki czemu jest ona bardziej kompaktowa i osi\u0105ga wy\u017csz\u0105 pr\u0119dko\u015b\u0107 ni\u017c architektura \"frame transfer\".\n\nW procesie odczytu ka\u017cdego piksela, sygna\u0142 jest wzmacniany i przekszta\u0142cany w posta\u0107 cyfrow\u0105, a nast\u0119pnie zapisywany w pami\u0119ci kamery. W ten spos\u00f3b, obraz jest tworzony z wielu pikseli, kt\u00f3re s\u0105 odczytywane sekwencyjnie i zapisywane na karcie pami\u0119ci kamery.\n\nKamery CCD znajduj\u0105 zastosowanie w wielu r\u00f3\u017cnych dziedzinach, w tym w systemach telewizyjnych, przemys\u0142owych, medycznych i naukowych. Dzi\u0119ki ich wysokiej rozdzielczo\u015bci i czu\u0142o\u015bci na \u015bwiat\u0142o, kamery CCD s\u0105 idealnym wyborem do wykonywania zdj\u0119\u0107 i film\u00f3w o wysokiej jako\u015bci i ostro\u015bci."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "impedancja \u017ar\u00f3d\u0142owa.\n\nNie jest jasne, jakie jest pytanie. Prosz\u0119 poda\u0107 pe\u0142ne pytanie."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym, kt\u00f3re opisuje jego zachowanie w czasie:\n\ndy/dt = f(y, t)\n\ngdzie y oznacza stan czujnika, t oznacza czas, a f jest funkcj\u0105 opisuj\u0105c\u0105 spos\u00f3b, w jaki y zmienia si\u0119 w czasie.\n\nR\u00f3wnanie to opisuje, jak sygna\u0142 pochodz\u0105cy z czujnika (oznaczony jako y) zmienia si\u0119 w czasie, w zale\u017cno\u015bci od warto\u015bci czasu t oraz charakterystyki czujnika zdefiniowanej przez funkcj\u0119 f.\n\nRozwi\u0105zanie tego r\u00f3wnania pozwala na okre\u015blenie, jak sygna\u0142 pochodz\u0105cy z czujnika b\u0119dzie zmienia\u0142 si\u0119 w czasie oraz jak reagowa\u0107 na jego zmiany. Rozwi\u0105zania tego typu r\u00f3wna\u0144 s\u0105 cz\u0119sto stosowane w r\u00f3\u017cnych dziedzinach, takich jak fizyka, in\u017cynieria, biologia czy ekonomia, by opisywa\u0107 i przewidywa\u0107 zachowanie r\u00f3\u017cnych proces\u00f3w i zjawisk."
      }
    ],
    "#n": 11
  },
  "## Plik. 12": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter analogowo-cyfrowy (ADC) jest urz\u0105dzeniem, kt\u00f3re przekszta\u0142ca sygna\u0142 analogowy na posta\u0107 cyfrow\u0105. Dzia\u0142anie ADC polega na pr\u00f3bkowaniu sygna\u0142u analogowego co okre\u015blony czas oraz kwantowaniu \u2013 przyporz\u0105dkowaniu warto\u015bci cyfrowej do amplitudy pr\u00f3bek. \n\nProces ten mo\u017cna przedstawi\u0107 nast\u0119puj\u0105co:\n\n1. Sygna\u0142 analogowy jest podawany na wej\u015bcie ADC.\n2. Sygna\u0142 jest pr\u00f3bkowany z okre\u015blon\u0105 cz\u0119stotliwo\u015bci\u0105 f_s, kt\u00f3ra jest wyra\u017cana w Hz (np. 10 kHz). \n3. Nast\u0119pnie sygna\u0142 jest kwantowany, czyli przetwarzany na warto\u015bci dyskretne z okre\u015blon\u0105 rozdzielczo\u015bci\u0105. Rozdzielczo\u015b\u0107 okre\u015blana jest przez liczb\u0119 bit\u00f3w u\u017cytych do zapisu warto\u015bci cyfrowej. Im wi\u0119cej bit\u00f3w, tym mniejsze skoki mi\u0119dzy kolejnymi warto\u015bciami cyfrowymi. Na przyk\u0142ad: \n   - dla 8 bit\u00f3w rozdzielczo\u015bci (typowy zakres 0-255), ka\u017cda jednostka zmiany sygna\u0142u odpowiada zmianie o oko\u0142o 0,4% maksymalnej warto\u015bci sygna\u0142u.\n   - dla 16 bit\u00f3w rozdzielczo\u015bci (typowy zakres 0-65535), ka\u017cda jednostka zmiany sygna\u0142u odpowiada zmianie o oko\u0142o 0,0015% maksymalnej warto\u015bci sygna\u0142u.\n4. Warto\u015bci cyfrowe zostaj\u0105 zapisane w pami\u0119ci ADC i s\u0105 gotowe do przetworzenia przez cyfrowy uk\u0142ad elektroniczny. \n\nObliczenia:\n\nCz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania f_s jest odwrotno\u015bci\u0105 czasu trwania jednej pr\u00f3bki T_s, czyli: \nf_s = 1/T_s\n\nRozdzielczo\u015b\u0107 ADC dla n bit\u00f3w wynosi:\nR = (V_max - V_min)/(2^n)\n\ngdzie V_max to maksymalna warto\u015b\u0107 sygna\u0142u analogowego, a V_min to minimalna warto\u015b\u0107 sygna\u0142u analogowego. \n\nPrzyk\u0142adowo, dla ADC o rozdzielczo\u015bci 12 bit\u00f3w i zakresie 0-5 V, rozdzielczo\u015b\u0107 wynosi: \nR = (5 V - 0 V)/(2^12) = 0,00122 V\n\nOznacza to, \u017ce ka\u017cda jednostka zmiany sygna\u0142u odpowiada zmianie o oko\u0142o 0,024% maksymalnej warto\u015bci sygna\u0142u."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwoma fazami aktywnymi.\n\nSilnik krokowy to urz\u0105dzenie, kt\u00f3re przekszta\u0142ca impulsy elektryczne dostarczane na jego cewki w ruch mechaniczny. W trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105 do przeprowadzenia ka\u017cdego pe\u0142nego kroku, potrzebna jest zmiana stanu jednej fazy. W kolejnych etapach, ka\u017cda cewka zmienia sw\u00f3j stan, co powoduje ruch osi. W przypadku takiego trybu, silnik krokowy obraca si\u0119 z mniejsz\u0105 pr\u0119dko\u015bci\u0105, ale z wi\u0119ksz\u0105 si\u0142\u0105.\n\nNatomiast w trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi, ka\u017cda kolejna cewka zostaje aktywowana naprzemiennie, dzi\u0119ki czemu osi\u0105gane jest wi\u0119ksze przyspieszenie i wi\u0119ksza pr\u0119dko\u015b\u0107 obrotowa przy mniejszej mocy. Dzi\u0119ki manipulacji sygna\u0142ami elektrycznymi, silnik krokowy obraca si\u0119 z wi\u0119ksz\u0105 pr\u0119dko\u015bci\u0105, ale z mniejsz\u0105 si\u0142\u0105.\n\nW obu trybach, kontroler silnika krokowego musi ustawi\u0107 kolejno\u015b\u0107 aktywacji faz, aby zapewni\u0107 odpowiedni kierunek ruchu i odpowiedni\u0105 ilo\u015b\u0107 krok\u00f3w odpowiednio do wymaga\u0144 aplikacji. Cz\u0119stotliwo\u015b\u0107 sygna\u0142\u00f3w elektrycznych dostarczanych do cewek, decyduje o pr\u0119dko\u015bci obrotowej silnika."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany czujnik mo\u017ce by\u0107 opisany r\u00f3wnaniem r\u00f3\u017cniczkowym w postaci:\n\ny'(t) = f(x(t), y(t), t)\n\ngdzie y jest warto\u015bci\u0105 wyj\u015bciow\u0105 czujnika, x jest warto\u015bci\u0105 wej\u015bciow\u0105, t jest czasem, a f jest funkcj\u0105 opisuj\u0105c\u0105 charakterystyk\u0119 czujnika.\n\nW zale\u017cno\u015bci od konkretnego czujnika, funkcja f mo\u017ce mie\u0107 r\u00f3\u017cn\u0105 posta\u0107 i zale\u017ce\u0107 od wielu czynnik\u00f3w, takich jak temperatura, wilgotno\u015b\u0107, ci\u015bnienie, nat\u0119\u017cenie o\u015bwietlenia czy intensywno\u015b\u0107 pola magnetycznego.\n\nR\u00f3wnanie r\u00f3\u017cniczkowe opisuj\u0105ce czujnik jest wa\u017cne, poniewa\u017c umo\u017cliwia predykcj\u0119 jego zachowania w czasie oraz pozwala na opracowanie odpowiedniej strategii kalibracji i ustawienia."
      }
    ],
    "#n": 12
  },
  "## Plik. 13": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera cyfrowo-analogowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter cyfrowo-analogowy (DAC) jest urz\u0105dzeniem, kt\u00f3re przyjmuje cyfrowy sygna\u0142 wej\u015bciowy i przekszta\u0142ca go na analogowy sygna\u0142 wyj\u015bciowy. Proces ten polega na przydzieleniu warto\u015bci sygna\u0142u cyfrowego do odpowiednich poziom\u00f3w napi\u0119cia na wyj\u015bciu konwertera.\n\nDAC zwykle sk\u0142ada si\u0119 z trzech g\u0142\u00f3wnych komponent\u00f3w: rejestru przesuwnego, przetwornika wagowego i wzmacniacza.\n\nRejestr przesuwny s\u0142u\u017cy do przechowywania kolejnych bit\u00f3w sygna\u0142u cyfrowego i przesuwania ich przez system, aby uzyska\u0107 kolejne warto\u015bci sygna\u0142u. Przetwornik wagowy przetwarza warto\u015bci bit\u00f3w z rejestru przesuwnego na napi\u0119cia odpowiednie dla ka\u017cdej warto\u015bci. Oddzielne przetworniki wagowe maj\u0105 r\u00f3\u017cn\u0105 precyzj\u0119, aby osi\u0105gn\u0105\u0107 odpowiedni\u0105 jako\u015b\u0107 sygna\u0142u.\n\nWzmacniacz s\u0142u\u017cy do wzmocnienia sygna\u0142u wyj\u015bciowego do odpowiedniego poziomu napi\u0119cia, kt\u00f3ry b\u0119dzie odpowiedni dla urz\u0105dze\u0144 odbiorczych, takich jak g\u0142o\u015bniki lub przetworniki sygna\u0142u.\n\nObliczenia dotycz\u0105ce dzia\u0142ania konwertera cyfrowo-analogowego obejmuj\u0105 dobranie napi\u0119\u0107 minimalnego i maksymalnego, potrzebnych do uzyskania odpowiedniego zakresu sygna\u0142u wyj\u015bciowego. Przyk\u0142adowo, je\u015bli DAC ma zakres wyj\u015bciowy od 0 do 5 wolt\u00f3w i przetwornik wagowy ma 8 bit\u00f3w, obliczenia b\u0119d\u0105 wygl\u0105da\u0107 nast\u0119puj\u0105co:\n\n- Warto\u015b\u0107 minimalna sygna\u0142u cyfrowego: 00000000 (0)\n- Warto\u015b\u0107 maksymalna sygna\u0142u cyfrowego: 11111111 (255)\n- Zakres warto\u015bci przetworzonych na napi\u0119cie: 0-5V\n- Warto\u015b\u0107 napi\u0119cia dla ka\u017cdej warto\u015bci sygna\u0142u cyfrowego: 5 / 255 = ~0.0196 V\n\nNast\u0119pnie, w celu uzyskania warto\u015bci sygna\u0142u analogowego dla konkretnej warto\u015bci cyfrowej, ta warto\u015b\u0107 zostaje pomno\u017cona przez warto\u015b\u0107 napi\u0119cia dla ka\u017cdego bitu wagowego i dodana do siebie, aby uzyska\u0107 sumaryczn\u0105 warto\u015b\u0107 napi\u0119cia dla ca\u0142ego sygna\u0142u analogowego."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze p\u00f3\u0142przewodnikowe typu P-N sk\u0142ada si\u0119 z dw\u00f3ch warstw p\u00f3\u0142przewodnik\u00f3w z r\u00f3\u017cnymi rodzajami przewodnictwa. Warstwa typu P ma nadmiar dziurek, kt\u00f3re s\u0105 no\u015bnikami \u0142adunk\u00f3w dodatnich, natomiast warstwa typu N ma nadmiar elektron\u00f3w, kt\u00f3re s\u0105 no\u015bnikami \u0142adunk\u00f3w ujemnych.\n\nW z\u0142\u0105czu P-N zachodzi zjawisko wy\u015bcielania, czyli migracja no\u015bnik\u00f3w \u0142adunku na granicy pomi\u0119dzy dwoma r\u00f3\u017cnymi typami p\u00f3\u0142przewodnik\u00f3w. W wyniku tego procesu nast\u0119puje nier\u00f3wnomierne roz\u0142o\u017cenie \u0142adunk\u00f3w po obu stronach z\u0142\u0105cza. Na tej granicy powstaje pole elektryczne, kt\u00f3re prowadzi do zatrzymania dalniejszej migracji no\u015bnik\u00f3w.\n\nW z\u0142\u0105czu P-N dochodzi r\u00f3wnie\u017c do zjawiska rekombinacji, czyli spotkania elektron\u00f3w i dziurek i tworzenia par zwi\u0105zanych ladunkowo. Podczas tego procesu powstaje energia, kt\u00f3ra mo\u017ce by\u0107 emitowana w postaci foton\u00f3w. Ten efekt wykorzystywany jest w diodach LED, gdzie energia emitowana jest w postaci \u015bwiat\u0142a.\n\nKolejnym zjawiskiem zachodz\u0105cym w z\u0142\u0105czu P-N jest dioda prostownicza, gdzie po\u0142\u0105czenie warstwy typu P z dodatnim biegunem zasilacza, a warstwa typu N z ujemnym biegunem pozwala na przep\u0142yw pr\u0105du jednokierunkowego. Pr\u0105d sprzyja dalszej rekombinacji no\u015bnik\u00f3w \u0142adunk\u00f3w, co prowadzi do zwi\u0119kszenia pola elektrycznego na z\u0142\u0105czu.\n\nOg\u00f3lnie rzecz bior\u0105c, w z\u0142\u0105czu P-N zachodz\u0105 bardzo interesuj\u0105ce zjawiska, kt\u00f3re umo\u017cliwiaj\u0105 wykorzystanie p\u00f3\u0142przewodnik\u00f3w w wielu dziedzinach, takich jak elektronika, przemys\u0142, energetyka i wiele innych."
      },
      {
        "Zad. 3 Wyznacz (przybli\u017con\u0105) liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, dla kt\u00f3rego zebrano do\u015bwiadczalnie": "nast\u0119puj\u0105ce pomiary:\n\n| Wej\u015bcie [V] | Wyj\u015bcie [mA] |\n|------------|--------------|\n| 0          | 0            |\n| 1.5        | 15           |\n| 2.5        | 25           |\n| 3.5        | 35           |\n| 4.5        | 45           |\n| 5          | 50           |\n\nAby wyznaczy\u0107 przybli\u017con\u0105 liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, musimy znale\u017a\u0107 r\u00f3wnanie prostej, kt\u00f3ra najlepiej odwzoruje te punkty pomiarowe. Mo\u017cemy to zrobi\u0107 za pomoc\u0105 metody najmniejszych kwadrat\u00f3w.\n\nNajpierw wyznaczmy \u015brednie warto\u015bci wej\u015bcia i wyj\u015bcia:\n\n$$\\overline{x} = \\frac{\\sum{x_i}}{n} = \\frac{0 + 1.5 + 2.5 + 3.5 + 4.5 + 5}{6} = 2.5$$\n\n$$\\overline{y} = \\frac{\\sum{y_i}}{n} = \\frac{0 + 15 + 25 + 35 + 45 + 50}{6} = 28.33\\text{ mA}$$\n\nNast\u0119pnie wyznaczmy r\u00f3\u017cnice mi\u0119dzy pomiarami a \u015brednimi warto\u015bciami:\n\n$$\\Delta x_i = x_i - \\overline{x}$$\n\n$$\\Delta y_i = y_i - \\overline{y}$$\n\n|i  |$x_i$|$y_i$|$\\Delta x_i$|$\\Delta y_i$|$\\Delta x_i^2$|$\\Delta x_i \\Delta y_i$|\n|---|---|---|---------|---------|------------|-------------|\n|1  |0  |0  |-2.5     |-28.33   |6.25        |70.83        |\n|2  |1.5|15 | -1      |-13.33   |1           |13.33        |\n|3  |2.5|25 | 0.5     |-3.33    |0.25        |-1.67        |\n|4  |3.5|35 | 1.5     | 6.67    |2.25        |10.03        |\n|5  |4.5|45 | 2.5     |16.67    |6.25        |41.67        |\n|6  |5  |50 | 2.5     |21.67    |6.25        |54.17        |\n|\u03a3  |2.5|28.33|0      |0        |22          |188.33       |\n\nNast\u0119pnie wyznaczmy wsp\u00f3\u0142czynniki prostej przy u\u017cyciu wzor\u00f3w:\n\n$$k = \\frac{\\sum{\\Delta x_i\\Delta y_i}}{\\sum{\\Delta x_i^2}} = \\frac{188.33}{22} = 8.56\\text{ mA/V}$$\n\n$$b = \\overline{y} - k\\overline{x} = 28.33 - 8.56 \\cdot 2.5 = 6.67\\text{ mA}$$\n\nOstatecznie, r\u00f3wnanie prostej przybli\u017caj\u0105cej charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika wynosi:\n\n$$y = 8.56x + 6.67$$\n\nMo\u017cemy teraz u\u017cy\u0107 tego r\u00f3wnania, aby przewidzie\u0107 warto\u015bci wyj\u015bcia dla r\u00f3\u017cnych warto\u015bci wej\u015bcia, kt\u00f3re nie by\u0142y obj\u0119te pomiarami eksperymentalnymi. Jednak nale\u017cy pami\u0119ta\u0107, \u017ce przybli\u017cona charakterystyka liniowa mo\u017ce nie by\u0107 dok\u0142adna w ca\u0142ym zakresie dzia\u0142ania czujnika."
      }
    ],
    "#n": 13
  },
  "## Plik. 14": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij zastosowanie Supervisor-a w oprogramowaniu Webots. Poka\u017c jak i jakie instrukcje s\u0142u\u017c\u0105 do odczytywania": "i modyfikowania parametr\u00f3w symulacji za pomoc\u0105 Supervisor-a.\n\nSupervisor w Webots to proces, kt\u00f3ry zarz\u0105dza symulacj\u0105 robot\u00f3w i \u015brodowiska. Jego g\u0142\u00f3wnym zadaniem jest kontrolowanie symulacji, w tym modyfikowanie parametr\u00f3w, odczytywanie informacji o robotach i zmiana zachowania obiekt\u00f3w symulacji. Supervisor korzysta z j\u0119zyka Python, co umo\u017cliwia u\u017cytkownikom \u0142atwe programowanie interakcji mi\u0119dzy robotami i \u015brodowiskiem symulacyjnym. \n\nAby odczyta\u0107 parametry symulacji za pomoc\u0105 Supervisor-a, mo\u017cemy u\u017cy\u0107 nast\u0119puj\u0105cych instrukcji:\n\n```python\ntime_step = int(robot.getBasicTimeStep())\n```\n\nJest to przyk\u0142ad instrukcji, kt\u00f3ra pobiera warto\u015b\u0107 podstawowego kroku czasowego u\u017cywanego w symulacji, kt\u00f3ry mo\u017ce by\u0107 p\u00f3\u017aniej wykorzystany dla potrzeb sterowania robotem.\n\nAby zmieni\u0107 parametry symulacji, mo\u017cemy u\u017cy\u0107 na przyk\u0142ad nast\u0119puj\u0105cej instrukcji:\n\n```python\nrobot.setJointTargetPosition(joint_names, joint_positions)\n```\n\nJest to instrukcja, kt\u00f3ra ustawia pozycj\u0119 staw\u00f3w robota na okre\u015blonych pozycjach. Zamiast \"joint_names\" nale\u017cy poda\u0107 nazw\u0119 stawu, a zamiast \"joint_positions\" - warto\u015b\u0107 pozycji w radianach. \n\nInn\u0105 przyk\u0142adow\u0105 instrukcj\u0105 mo\u017ce by\u0107:\n\n```python\nrobot_node = supervisor.getFromDef(\"ROBOT\")\ntranslation_field = robot_node.getField(\"translation\")\ntranslation = translation_field.getSFVec3f()\n```\n\nInstrukcja ta pobiera pozycj\u0119 robota (wsp\u00f3\u0142rz\u0119dne x, y, z) i przypisuje j\u0105 do zmiennej \"translation\". \n\nZastosowanie Supervisor-a w Webots jest szczeg\u00f3lnie przydatne w przypadku ch\u0119ci personalizowania parametr\u00f3w symulacji i dodawania nowych funkcjonalno\u015bci do robot\u00f3w. Umo\u017cliwia to u\u017cytkownikom tworzenie bardziej z\u0142o\u017conych program\u00f3w, kt\u00f3re wykorzystuj\u0105 dane z symulacji do tworzenia bardziej interaktywnej i realistycznej wirtualnej rzeczywisto\u015bci."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 manipulatora SCARA.": "Ruchliwo\u015b\u0107 manipulatora SCARA mo\u017cna obliczy\u0107 z u\u017cyciem r\u00f3wnania:\n\nR = 6 - n - m \n\ngdzie:\nR - ruchliwo\u015b\u0107 manipulatora SCARA\nn - liczba stopni swobody (niezale\u017cnych po\u0142o\u017ce\u0144) w p\u0142aszczy\u017anie roboczej ramienia poziomego\nm - liczba stopni swobody w kierunku pionowym (zwykle jeden, dla podnoszenia i opuszczania narz\u0119dzia)\n\nDla typowego manipulatora SCARA, kt\u00f3ry ma trzy stopnie swobody w p\u0142aszczy\u017anie roboczej ramienia poziomego i jeden stopie\u0144 swobody w kierunku pionowym, ruchliwo\u015b\u0107 wynosi: \n\nR = 6 - 3 - 1 = 2 \n\nOznacza to, \u017ce manipulator SCARA mo\u017ce porusza\u0107 si\u0119 w dw\u00f3ch niezale\u017cnych kierunkach w tr\u00f3jwymiarowej przestrzeni roboczej."
      }
    ],
    "#n": 14
  },
  "## Plik. 15": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij poj\u0119cie przekszta\u0142ce\u0144 jednorodnych.": "Przekszta\u0142cenia jednorodne to takie dzia\u0142ania matematyczne, kt\u00f3re zachowuj\u0105 proporcjonalno\u015b\u0107 mi\u0119dzy zmiennymi. Oznacza to, \u017ce je\u015bli mno\u017cymy warto\u015bci zmiennych przez pewn\u0105 sta\u0142\u0105, to wynik przekszta\u0142cenia r\u00f3wnie\u017c zostanie pomno\u017cony przez t\u0119 sam\u0105 sta\u0142\u0105. \n\nFormalnie, przekszta\u0142cenie f nazywamy jednorodnym stopnia k, je\u015bli dla dowolnego x i dowolnej sta\u0142ej c zachodzi:\n\nf(cx) = c^k * f(x)\n\nPrzyk\u0142adem przekszta\u0142cenia jednorodnego jest pierwiastkowanie, poniewa\u017c dla dowolnego x i dowolnej sta\u0142ej c zachodzi:\n\nsqrt(c * x) = sqrt(c) * sqrt(x)\n\nInnym przyk\u0142adem s\u0105 przekszta\u0142cenia afiniczne, czyli przesuni\u0119cia, obroty i skalowania figur geometrycznych. Skalowanie jest przyk\u0142adem przekszta\u0142cenia jednorodnego stopnia 2, poniewa\u017c podwojenie d\u0142ugo\u015bci kraw\u0119dzi figury skutkuje jej czterokrotnym powi\u0119kszeniem powierzchni."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 (typowego) manipulatora ramieniowego.": "Ruchliwo\u015b\u0107 manipulatora ramieniowego zale\u017cy od liczby stopni swobody (DOF - degrees of freedom), czyli liczby niezale\u017cnych kierunk\u00f3w, w kt\u00f3rych mo\u017ce si\u0119 porusza\u0107. Typowy manipulator ramieniowy posiada 6 stopni swobody, co oznacza, \u017ce mo\u017ce porusza\u0107 si\u0119 w 6 niezale\u017cnych kierunkach. \n\nRuchliwo\u015b\u0107 ta jest zwykle wykorzystywana do okre\u015blenia zdolno\u015bci manipulatora do wykonywania skomplikowanych ruch\u00f3w i precyzyjnej kontroli pozycji narz\u0119dzia. Im wi\u0119ksza jest liczba stopni swobody, tym bardziej zaawansowane zadania manipulator mo\u017ce wykonywa\u0107. Jednocze\u015bnie wi\u0119ksza liczba stopni swobody oznacza zwykle wi\u0119ksz\u0105 z\u0142o\u017cono\u015b\u0107 mechanizmu i wi\u0119ksze koszty budowy i utrzymania."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie": "Zadanie:\n\nRozwa\u017cmy manipulator z\u0142o\u017cony z jednego \u0142\u0105cza obrotowego zamontowanego na bazie. K\u0105t obrotu \u0142\u0105cza wynosi 30 stopni na sekund\u0119. Jakie jest pr\u0119dko\u015bci liniowe i k\u0105towe ko\u0144ca manipulatora znajduj\u0105cego si\u0119 w odleg\u0142o\u015bci 0.5m od osi obrotu?\n\nRozwi\u0105zanie:\n\nPr\u0119dko\u015b\u0107 k\u0105towa \u0142\u0105cza mo\u017cna zapisa\u0107 jako:\n\n\u03c9 = 30\u00b0/s = 0.524 rad/s\n\nPr\u0119dko\u015b\u0107 liniowa ko\u0144ca manipulatora mo\u017cna obliczy\u0107 jako:\n\nv = \u03c9 * r\n\ngdzie r = 0.5m jest odleg\u0142o\u015bci\u0105 ko\u0144ca manipulatora od osi obrotu.\n\nv = 0,524 rad/s * 0,5 m = 0,262 m/s\n\nPr\u0119dko\u015b\u0107 k\u0105towa ko\u0144ca manipulatora jest taka sama jak pr\u0119dko\u015b\u0107 k\u0105towa \u0142\u0105cza.\n\n\u03c9_konca = \u03c9 = 0.524 rad/s\n\nOdpowied\u017a:\n\nPr\u0119dko\u015b\u0107 liniowa ko\u0144ca manipulatora wynosi 0.262 m/s, a pr\u0119dko\u015b\u0107 k\u0105towa ko\u0144ca manipulatora wynosi 0.524 rad/s."
      }
    ],
    "#n": 15
  },
  "## Plik. 16": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij przeznaczenie poszczeg\u00f3lnych bit\u00f3w rejestru STATUS.": "Rejestr STATUS jest rejstrem wewn\u0119trznym procesora, kt\u00f3ry zawiera informacje o stanie procesora oraz wynikach ostatnio wykonanych operacji.\n\nPoszczeg\u00f3lne bity rejestru STATUS pe\u0142ni\u0105 nast\u0119puj\u0105ce funkcje:\n\n- bit C (Carry) - przeniesienie po wykonaniu operacji arytmetycznej lub logicznej\n- bit DC (Digit Carry) - przeniesienie w przypadku operacji na cyfrach dziesi\u0119tnych\n- bit Z (Zero) - wynik ostatniej operacji by\u0142 r\u00f3wny zeru\n- bit PD (Power Down) - procesor znajduje si\u0119 w trybie oszcz\u0119dzania energii\n- bit TO (Time-out) - wyst\u0105pi\u0142o przerwanie zegara wewn\u0119trznego\n- bit RP0 (Register Bank Select) - wyb\u00f3r banku rejestr\u00f3w\n- bit IRP (Register Bank Select) - wyb\u00f3r banku rejestr\u00f3w\n- bit n/A (Not Applicable) - niewykorzystywany\n\nKa\u017cdy z bit\u00f3w rejestru STATUS ma swoje unikalne przeznaczenie, kt\u00f3re zale\u017cy od trybu pracy procesora i wykonywanych operacji. Na podstawie stanu rejestr\u00f3w mo\u017cna kontrolowa\u0107 przebieg programu i podejmowa\u0107 dalsze decyzje w zale\u017cno\u015bci od wynik\u00f3w operacji."
      },
      {
        "Zad. 2 Wykonaj obr\u00f3t punktu [1,1,1]o30\u25e6dooko\u0142a wektora [0.5,0.4,0.3]. Zamie\u015b\u0107 odpowiednie obliczenia.": "W pierwszej kolejno\u015bci nale\u017cy przekszta\u0142ci\u0107 wektor [0.5,0.4,0.3] na wektor jednostkowy, dziel\u0105c go przez jego d\u0142ugo\u015b\u0107:\n\n||[0.5,0.4,0.3]|| = sqrt(0.5^2 + 0.4^2 + 0.3^2) = 0.744\n\n[0.5,0.4,0.3]/0.744 = [0.671,0.536,0.402]\n\nNast\u0119pnie, korzystaj\u0105c z wzoru na macierz obrotu dla dowolnego k\u0105ta i osi, mamy:\n\n|cos\u03b8+(1-cos\u03b8)a_x^2    a_xa_y(1-cos\u03b8)-a_zsin\u03b8  a_xa_z(1-cos\u03b8)+a_ysin\u03b8|\n|a_ya_x(1-cos\u03b8)+a_zsin\u03b8 cos\u03b8+(1-cos\u03b8)a_y^2    a_ya_z(1-cos\u03b8)-a_xsin\u03b8|\n|a_za_x(1-cos\u03b8)-a_ysin\u03b8 a_za_y(1-cos\u03b8)+a_xsin\u03b8 cos\u03b8+(1-cos\u03b8)a_z^2   |\n\nDla naszych danych, warto\u015bci a_x, a_y, a_z to odpowiednio 0.671, 0.536 i 0.402, a k\u0105t obrotu \u03b8 to 30 stopni. Podstawiaj\u0105c te warto\u015bci, otrzymujemy:\n\n|0.868  -0.350  0.350 |\n|0.350   0.936 -0.002 |\n|-0.350  0.002  0.936|\n\nOstatecznie, wykonuj\u0105c mno\u017cenie macierzowe punktu [1,1,1] przez uzyskan\u0105 powy\u017cej macierz obrotu, otrzymujemy:\n\n[0.868,0.650,1.286]"
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na": "podstawie obrotowej. Zak\u0142adaj\u0105c, \u017ce pozioma podstawa obrotowa porusza si\u0119 z pr\u0119dko\u015bci\u0105 sta\u0142\u0105, a \u0142\u0105cze porusza si\u0119 wzd\u0142u\u017c osi pryzmatu z pr\u0119dko\u015bci\u0105 proporcjonaln\u0105 do k\u0105ta obrotu podstawy.\n\nRozwi\u0105zanie:\n\nDla prostoty przyjmujemy, \u017ce manipulator porusza si\u0119 tylko w jednym wymiarze (os X). Oznaczamy przez:\n\n- \u03b8(t): k\u0105t obrotu podstawy w czasie t\n- x(t): po\u0142o\u017cenie ko\u0144ca \u0142\u0105cza w czasie t\n- L: d\u0142ugo\u015b\u0107 \u0142\u0105cza\n\nZ tre\u015bci zadania wynika, \u017ce pr\u0119dko\u015b\u0107 k\u0105towa podstawy jest sta\u0142a, czyli:\n\nd\u03b8/dt = const.\n\nNatomiast pr\u0119dko\u015b\u0107 liniowa ko\u0144ca \u0142\u0105cza jest proporcjonalna do pr\u0119dko\u015bci k\u0105towej podstawy, czyli:\n\ndx/dt = k * d\u03b8/dt\n\ngdzie k jest sta\u0142\u0105 proporcjonalno\u015bci.\n\nZauwa\u017camy, \u017ce \u0142\u0105cze porusza si\u0119 po linii prostej, wi\u0119c jego przemieszczenie mo\u017cna opisa\u0107 za pomoc\u0105 funkcji liniowej:\n\nx(t) = a * \u03b8(t) + b\n\ngdzie a i b s\u0105 sta\u0142ymi do wyznaczenia. Wykorzystuj\u0105c warunek pocz\u0105tkowy x(0) = 0, otrzymujemy:\n\nb = 0\n\nTeraz musimy obliczy\u0107 warto\u015b\u0107 sta\u0142ej a. Do tego celu wykorzystujemy drugi warunek:\n\ndx/dt = k * d\u03b8/dt\n\nOznaczaj\u0105c pochodn\u0105 k\u0105ta jako \u03c9 = d\u03b8/dt, mamy:\n\na * \u03c9 = k * \u03c9\n\nst\u0105d:\n\na = k\n\nW rezultacie otrzymujemy r\u00f3wnanie opisuj\u0105ce po\u0142o\u017cenie ko\u0144ca \u0142\u0105cza w czasie t:\n\nx(t) = k * \u03b8(t)\n\nTeraz mo\u017cemy obliczy\u0107 pr\u0119dko\u015b\u0107 i przyspieszenie ko\u0144ca \u0142\u0105cza. Pr\u0119dko\u015b\u0107 to pochodna po czasie:\n\nv(t) = dx/dt = k * d\u03b8/dt = k * \u03c9\n\nZ kolei przyspieszenie to druga pochodna po czasie:\n\na(t) = dv/dt = k * d\u03c9/dt\n\nAby wyznaczy\u0107 d\u03c9/dt, musimy skorzysta\u0107 z faktu, \u017ce pr\u0119dko\u015b\u0107 k\u0105towa jest sta\u0142a:\n\nd\u03c9/dt = 0\n\nSt\u0105d:\n\na(t) = 0\n\nOznacza to, \u017ce przyspieszenie ko\u0144ca \u0142\u0105cza jest zerowe, czyli ruch jest jednostajny z pr\u0119dko\u015bci\u0105 v = k * \u03c9."
      }
    ],
    "#n": 16
  },
  "## Plik. 17": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci programu w mikrokontrolerze PIC16f877A.": "Mikrokontroler PIC16f877A ma 13-bitow\u0105 przestrze\u0144 adresow\u0105, co oznacza, \u017ce \u200b\u200bmo\u017ce obs\u0142ugiwa\u0107 do 8KB pami\u0119ci. Sposoby adresacji pami\u0119ci programu w mikrokontrolerze PIC16f877A obejmuj\u0105:\n\n1. Bezpo\u015brednia adresacja - u\u017cywa bezpo\u015bredniego adresu 8-bitowego, kt\u00f3ry wskazuje na konkretny bajt pami\u0119ci. Na przyk\u0142ad, instrukcja \"MOVLW 0x0A\" \u0142aduje warto\u015b\u0107 0x0A do rejestru W, a instrukcja \"MOVWF 0x20\" zapisuje warto\u015b\u0107 w rejestrze W do adresu 0x20 w pami\u0119ci.\n\n2. Bezpo\u015brednia adresacja z przesuni\u0119ciem - u\u017cywa bezpo\u015bredniego adresu 8-bitowego i sta\u0142ej wzgl\u0119dnej, kt\u00f3ra okre\u015bla przesuni\u0119cie od adresu bazowego. Na przyk\u0142ad, instrukcja \"MOVLW 0x0A\" \u0142aduje warto\u015b\u0107 0x0A do rejestru W, a instrukcja \"MOVWF 0x20+2\" zapisuje warto\u015b\u0107 w rejestrze W do adresu 0x22 w pami\u0119ci (0x20 + 2).\n\n3. Indyrekcyjna adresacja - u\u017cywa warto\u015bci z rejestru, aby wyznaczy\u0107 adres pami\u0119ci. Na przyk\u0142ad, instrukcja \"MOVLW 0x10\" \u0142aduje warto\u015b\u0107 0x10 do rejestru W, a instrukcja \"MOVWF FSR\" ustawia FSR na adres 0x10. Nast\u0119pnie instrukcja \"MOVWF [FSR]\" zapisuje warto\u015b\u0107 w rejestrze W do adresu wskazywanego przez FSR.\n\n4. Indyrekcyjna adresacja z przesuni\u0119ciem - u\u017cywa rejestru i sta\u0142ej wzgl\u0119dnej, aby wyznaczy\u0107 adres pami\u0119ci. Na przyk\u0142ad, instrukcja \"MOVLW 0x10\" \u0142aduje warto\u015b\u0107 0x10 do rejestru W, a instrukcja \"MOVWF FSR\" ustawia FSR na adres 0x10. Nast\u0119pnie instrukcja \"MOVWF [FSR+2]\" zapisuje warto\u015b\u0107 w rejestrze W do adresu 0x12 (0x10 + 2) wskazywanego przez FSR.\n\n5. Adresacja sta\u0142a - u\u017cywa bezpo\u015bredniej warto\u015bci sta\u0142ej jako adresu pami\u0119ci. Na przyk\u0142ad, instrukcja \"MOVLW 0x0A\" \u0142aduje warto\u015b\u0107 0x0A do rejestru W, a instrukcja \"GOTO 0x100\" przeskakuje do adresu 0x100 w pami\u0119ci.\n\n6. Rozszerzona adresacja - u\u017cywa 21-bitowego adresu do dost\u0119pu do wi\u0119kszej pami\u0119ci. Ta forma adresacji jest dost\u0119pna tylko w pewnych trybach pracy i niekt\u00f3rych uk\u0142adach, a nie w standardowym trybie pracy PIC16f877A."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "Tekst na wy\u015bwietlaczu HD44780 mo\u017cna programowa\u0107 za pomoc\u0105 mikrokontrolera lub innego urz\u0105dzenia. Istnieje kilka metod programowania HD44780, ale poni\u017cej przedstawiono najpopularniejsz\u0105.\n\nChc\u0105c programowa\u0107 wy\u015bwietlacz HD44780, najpierw nale\u017cy skonfigurowa\u0107 porty mikrokontrolera, kt\u00f3re b\u0119d\u0105 bezpo\u015brednio po\u0142\u0105czone z wy\u015bwietlaczem. Nast\u0119pnie nale\u017cy dok\u0142adnie zapozna\u0107 si\u0119 z instrukcjami obs\u0142ugi LCD.\n\nW HD44780 s\u0105 cztery rejestry:\n\n1. Rejestr instrukcji - umo\u017cliwia przesy\u0142anie polece\u0144 do wy\u015bwietlacza, takich jak w\u0142\u0105czenie, wy\u0142\u0105czenie wy\u015bwietlacza.\n\n2. Rejestr danych - umo\u017cliwia przesy\u0142anie danych do wy\u015bwietlacza.\n\n3. Rejestr adresowy - kontroluje pozycj\u0119 kursora.\n\n4. Rejestr trybu pracy - kontorluje tryb pracy wy\u015bwietlacza.\n\nNajwa\u017cniejszymi instrukcjami dla programowania wy\u015bwietlacza HD44780 s\u0105:\n\n1. Instrukcja ustawienia trybu pracy - \"Function set\". Dzi\u0119ki niej kodujemy parametry trybu pracy wy\u015bwietlacza, takie jak: liczba wierszy (1 lub 2), wielko\u015b\u0107 czcionki, interfejs danych (4-bitowy lub 8-bitowy), tryb pracy (zwyk\u0142y lub rozszerzony).\n\n2. Instrukcja czyszczenia ekranu - \"Clear Display\". Usuwa ca\u0142y tekst z wy\u015bwietlacza i przenosi kursor na pozycj\u0119 pocz\u0105tkow\u0105.\n\n3. Instrukcja ustawienia pozycji kursora - \"Set DDRAM Address\". Pozwala na ustawienie pozycji kursora na wy\u015bwietlaczu.\n\n4. Instrukcja ustawienia kierunku tekstu - \"Entry Mode Set\". Ustawia kierunek tekstu na wy\u015bwietlaczu i spos\u00f3b przesuwania kursora po wpisaniu kolejnego znaku.\n\n5. Instrukcja wpisywania danych - \"Write Data\". Wpisuje pojedynczy znak na wy\u015bwietlacz.\n\n6. Instrukcja odczytania danych - \"Read Data\". Pozwala na odczytanie danych z wy\u015bwietlacza.\n\nZ uwagi na z\u0142o\u017cono\u015b\u0107 procesu programowania, zaleca si\u0119 korzysta\u0107 z gotowych bibliotek do obs\u0142ugi wy\u015bwietlacza HD44780. Dost\u0119pne s\u0105 biblioteki dla r\u00f3\u017cnych mikrokontroler\u00f3w i j\u0119zyk\u00f3w programowania."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105-": "czonego z jednym \u0142\u0105czem przegubowym.\n\nAby wyznaczy\u0107 parametry DH (Denavit-Hartenberg) dla tego manipulatora, nale\u017cy przeprowadzi\u0107 nast\u0119puj\u0105ce kroki:\n\n1. Wybierz uk\u0142ad odniesienia: W przypadku tego manipulatora nale\u017cy wybra\u0107 bie\u017c\u0105cy uk\u0142ad odniesienia (B), kt\u00f3ry znajduje si\u0119 na bazie.\n\n2. Okre\u015bl kierunek ruchu poprzecznego: Kierunek ruchu poprzecznego \u0142\u0105cza obrotowego (jednostopniowy) jest prostopad\u0142y do osi obrotu, zatem kierunek ten jest wyznaczony przez wektor jednostkowy i_hat = [1, 0, 0]^T.\n\n3. Zdefiniuj osie obrotu i uk\u0142ady wsp\u00f3\u0142rz\u0119dnych: W przypadku jednostopniowego \u0142\u0105cza obrotowego wystarczy zdefiniowa\u0107 jedn\u0105 o\u015b obrotu (z), kt\u00f3ra jest r\u00f3wnoleg\u0142a do osi obrotu \u0142\u0105cza. Aby okre\u015bli\u0107 uk\u0142ady wsp\u00f3\u0142rz\u0119dnych dla poszczeg\u00f3lnych \u0142\u0105cz, nale\u017cy zdefiniowa\u0107 uk\u0142ad wsp\u00f3\u0142rz\u0119dnych zwi\u0105zany z poprzednim \u0142\u0105czem (lub z uk\u0142adem bazowym w przypadku pierwszego \u0142\u0105cza) oraz uk\u0142ad wsp\u00f3\u0142rz\u0119dnych zwi\u0105zany z obecnym \u0142\u0105czem.\n\n4. Okre\u015bl punkt wsp\u00f3lny: Poniewa\u017c manipulator sk\u0142ada si\u0119 tylko z jednego \u0142\u0105cza obrotowego i jednego \u0142\u0105cza przegubowego, punkt wsp\u00f3lny mo\u017cna zdefiniowa\u0107 jako pocz\u0105tek \u0142\u0105cza obrotowego (w \u015brodku bazy).\n\n5. Okre\u015bl warto\u015bci parametr\u00f3w DH: Po okre\u015bleniu osi obrot\u00f3w i punktu wsp\u00f3lnego oraz zdefiniowaniu uk\u0142ad\u00f3w wsp\u00f3\u0142rz\u0119dnych dla poszczeg\u00f3lnych \u0142\u0105cz, mo\u017cna wyznaczy\u0107 warto\u015bci parametr\u00f3w DH dla ka\u017cdego \u0142\u0105cza:\n\n- a_i: D\u0142ugo\u015b\u0107 prostopad\u0142ej odleg\u0142o\u015bci mi\u0119dzy osi\u0105 z_{i-1} a z_i wzd\u0142u\u017c osi x_{i-1}.\n- alpha_i: K\u0105t mi\u0119dzy osi\u0105 z_{i-1} a z_i wzd\u0142u\u017c osi x_{i-1}.\n- d_i: D\u0142ugo\u015b\u0107 mi\u0119dzy osi\u0105 z_{i-1} a z_i wzd\u0142u\u017c osi z_i.\n- theta_i: K\u0105t mi\u0119dzy osi\u0105 x_{i-1} a x_i wzd\u0142u\u017c osi z_i.\n\nW przypadku tego manipulatora, parametry DH dla obu \u0142\u0105cz wynosz\u0105:\n\n- \u0142\u0105cze obrotowe:\n\n  - a_1 = 0\n  - alpha_1 = 0\n  - d_1 = 0\n  - theta_1 = q_1 (zmienna k\u0105towa)\n\n- \u0142\u0105cze przegubowe:\n\n  - a_2 = 0\n  - alpha_2 = 0\n  - d_2 = L (sta\u0142a d\u0142ugo\u015b\u0107 \u0142\u0105cza)\n  - theta_2 = q_2 (zmienna k\u0105towa)\n\ngdzie q_1 i q_2 oznaczaj\u0105 k\u0105t obrotu \u0142\u0105cz pierwszego i drugiego odpowiednio."
      }
    ],
    "#n": 17
  },
  "## Plik. 18": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci danych w mikrokontrolerze PIC16f877A.": "Mikrokontroler PIC16f877A u\u017cywa dw\u00f3ch sposob\u00f3w adresacji pami\u0119ci danych: bezpo\u015bredniej i po\u015bredniej.\n\nAdresowanie bezpo\u015brednie polega na bezpo\u015brednim odwo\u0142aniu do konkretnego adresu pami\u0119ci, w kt\u00f3rym znajduje si\u0119 dane. Adres ten mo\u017ce zosta\u0107 zdefiniowany w kodzie programu lub pobrany z rejestru. W przypadku PIC16f877A, zakres adresowania bezpo\u015bredniego wynosi od 0x00 do 0xFF i odnosi si\u0119 do rejestr\u00f3w wewn\u0119trznych, pami\u0119ci RAM oraz pami\u0119ci EEPROM.\n\nAdresowanie po\u015brednie jest u\u017cywane, gdy konkretny adres danych jest nieznany lub wymaga dynamicznego okre\u015blenia. W takim przypadku, adres danych jest zapisywany w rejestrze specjalnym, wskazuj\u0105cym na kolejny adres, kt\u00f3ry zawiera w\u0142a\u015bciwe dane. W PIC16f877A adresowanie po\u015brednie jest realizowane poprzez rejestry WREG, FSR oraz PCLATH.\n\nRejestr WREG (Working Register) s\u0142u\u017cy do przechowywania warto\u015bci tymczasowych lub do realizowania operacji arytmetycznych. W przypadku adresowania po\u015bredniego, warto\u015b\u0107 adresu pami\u0119ci jest zapisywana w rejestrze WREG.\n\nRejestr FSR (File Select Register) umo\u017cliwia wyb\u00f3r jednego z bank\u00f3w rejestr\u00f3w, w kt\u00f3rym znajduje si\u0119 adres pami\u0119ci. Warto\u015b\u0107 zapisana w rejestrze FSR jest dodawana do warto\u015bci z rejestru WREG, tworz\u0105c pe\u0142en adres pami\u0119ci.\n\nRejestr PCLATH (Program Counter Latch High) s\u0142u\u017cy do przechowywania cz\u0119\u015bci wysokiej adresu pami\u0119ci programu. W przypadku adresowania po\u015bredniego w pami\u0119ci programu, warto\u015b\u0107 z rejestr\u00f3w FSR i WREG dodawana jest do warto\u015bci PCLATH, aby utworzy\u0107 pe\u0142ny adres."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy (ADC) jest urz\u0105dzeniem, kt\u00f3re przekszta\u0142ca sygna\u0142 analogowy na sygna\u0142 cyfrowy. Spos\u00f3b dzia\u0142ania konwertera polega na por\u00f3wnywaniu sygna\u0142u wej\u015bciowego z sygna\u0142em referencyjnym i przekszta\u0142ceniu otrzymanej r\u00f3\u017cnicy na sygna\u0142 cyfrowy.\n\nW procesie przekszta\u0142cania sygna\u0142u analogowego na cyfrowy, istotne s\u0105 trzy etapy:\n\n1. Pr\u00f3bkowanie: polega na pobieraniu pr\u00f3bek sygna\u0142u analogowego w ustalonych odst\u0119pach czasowych.\n\n2. Kwantowanie: polega na przypisaniu warto\u015bci cyfrowej dla ka\u017cdej pobranej pr\u00f3bki sygna\u0142u analogowego.\n\n3. Kodowanie: polega na zapisaniu warto\u015bci cyfrowej w konkretnym formacie (np. binarnym).\n\nAby uruchomi\u0107 konwerter analogowo-cyfrowy, nale\u017cy wykona\u0107 kilka instrukcji:\n\n1. Wybra\u0107 odpowiedni tryb i konfiguracj\u0119 pracy.\n\n2. Ustawi\u0107 parametry sygna\u0142u wej\u015bciowego, takie jak zakres pomiarowy, cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, poziom sygna\u0142u referencyjnego.\n\n3. Uruchomi\u0107 konwersj\u0119 i przekaza\u0107 pobrane pr\u00f3bki do procesora lub mikrokontrolera.\n\n4. Odczyta\u0107 warto\u015bci cyfrowe i dokona\u0107 dalszej obr\u00f3bki lub analizy sygna\u0142u.\n\nKonwertery analogowo-cyfrowe s\u0105 powszechnie stosowane w systemach pomiarowych, przetwarzaniu sygna\u0142\u00f3w, regulacji i kontroli proces\u00f3w przemys\u0142owych oraz w elektronice u\u017cytkowej (np. w kamerach cyfrowych, smartfonach, czy tabletach)."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na bazie i": "dw\u00f3ch osi obrotowych:\n\n1. D\u0142ugo\u015b\u0107 \u0142\u0105cza pryzmatycznego: d1\n2. Odleg\u0142o\u015b\u0107 osi obrotowej pierwszego przegubu od bazy: a1\n3. Odleg\u0142o\u015b\u0107 osi obrotowej drugiego przegubu od ko\u0144ca \u0142\u0105cza pryzmatycznego: a2\n\nWyznaczanie parametr\u00f3w DH polega na przypisaniu uk\u0142adu wsp\u00f3\u0142rz\u0119dnych do ka\u017cdego z przegub\u00f3w robota oraz opracowaniu macierzy transformacji jednego uk\u0142adu do drugiego. Schemat DH dla manipulatora sk\u0142adaj\u0105cego si\u0119 z trzech przegub\u00f3w opisuje si\u0119 nast\u0119puj\u0105cymi przekszta\u0142ceniami:\n\n1. Piasty \u2013 Translacja wzd\u0142u\u017c osi Z (zdj\u0119cia ramienia od korpusu) o d1\n2. G\u0142\u00f3wny korpus \u2013 Obr\u00f3t wok\u00f3\u0142 osi Z (pozostaje sta\u0142e)\n3. (Pierwszy przegub) \u2013 Translacja wzd\u0142u\u017c osi X przesuni\u0119cie o a1 wzd\u0142u\u017c Z\n4. (Drugi przegub) \u2013 Translacja wzd\u0142u\u017c osi X przesuni\u0119cie o a2 wzd\u0142u\u017c Z.\n\nDefiniowanie parametr\u00f3w DH powinno poprawi\u0107 wa\u0142ki obracaj\u0105ce si\u0119 wok\u00f3\u0142 osi oraz przemieszczenia po osiach robota. Dzi\u0119ki temu b\u0119dzie mo\u017cliwe zaprojektowanie trajektorii ruchu robota, kt\u00f3re pozwol\u0105 na czyszczenie von Neumanna czy programowanie podobnych zada\u0144."
      }
    ],
    "#n": 18
  },
  "## Plik. 19": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz elementy pami\u0119ci programu mikrokontrolera PIC16f877A.": "Mikrokontroler PIC16f877A posiada nast\u0119puj\u0105ce elementy pami\u0119ci:\n\n1. Pami\u0119\u0107 flash - s\u0142u\u017cy do przechowywania programu u\u017cytkownika, kt\u00f3ry jest zapisywany czytelnym kodem asemblera i przechowywany w pami\u0119ci flash. Ta pami\u0119\u0107 jest nieulotna i pozwala na programowanie mikrokontrolera.\n\n2. Pami\u0119\u0107 EEPROM - ta pami\u0119\u0107 jest r\u00f3wnie\u017c nieulotna i s\u0142u\u017cy do przechowywania danych, kt\u00f3re s\u0105 zaprogramowane na sta\u0142e i nie ulegaj\u0105 zmianie. P\u0142ytka rozwojowa mikrokontrolera PIC16f877A ma 256 bajt\u00f3w pami\u0119ci EEPROM.\n\n3. Pami\u0119\u0107 RAM - ta pami\u0119\u0107 jest ulotna i s\u0142u\u017cy do przechowywania danych podczas dzia\u0142ania programu. Pami\u0119\u0107 RAM ma pojemno\u015b\u0107 368 bajt\u00f3w.\n\n4. Pami\u0119\u0107 rejestrowa - mikrokontrolery PIC maj\u0105 wiele rejestr\u00f3w, kt\u00f3re s\u0142u\u017c\u0105 do wykonywania r\u00f3\u017cnych operacji i przechowywania danych tymczasowych.\n\n5. Pami\u0119\u0107 programowa - s\u0142u\u017cy do przechowywania specjalnych instrukcji, kt\u00f3re pozwalaj\u0105 na kontrolowanie dzia\u0142ania mikrokontrolera.\n\nW sumie PIC16f877A oferuje a\u017c 14-bitowe adresowanie, przy jednoczesnym braku stronicowania, co daje do\u015b\u0107 du\u017cy zakres zastosowa\u0144 i \u0142atwo\u015b\u0107 programowania."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "rezystancja obci\u0105\u017cenia.\n\nNie ma rysunku do\u0142\u0105czonego do pytania, wi\u0119c nie mo\u017cemy dok\u0142adnie oceni\u0107, jak wygl\u0105da ten uk\u0142ad. Podstawowe informacje, kt\u00f3re podano, to impedancja uk\u0142adu zasilania (R1=50\u2126) i rezystancja obci\u0105\u017cenia (Rs=300\u2126). Mog\u0105 one by\u0107 stosowane do obliczenia warto\u015bci pr\u0105du i napi\u0119cia w uk\u0142adzie, ale konkretny wynik zale\u017cy od rodzaju uk\u0142adu i innych element\u00f3w sk\u0142adowych."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "y(t) = a * u(t) - b * y(t-1)\n\ngdzie y(t) oznacza warto\u015b\u0107 wyj\u015bciow\u0105 czujnika w chwili t, u(t) to sygna\u0142 wej\u015bciowy, a i b to sta\u0142e wsp\u00f3\u0142czynniki charakteryzuj\u0105ce w\u0142a\u015bciwo\u015bci czujnika. R\u00f3wnanie to opisuje dynamiczne zachowanie czujnika, gdzie jego wyj\u015bcie zale\u017cy nie tylko od sygna\u0142u wej\u015bciowego w danej chwili, ale tak\u017ce od wyj\u015bcia z poprzedniej chwili."
      }
    ],
    "#n": 19
  },
  "## Plik. 20": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz podstawowe elementy pami\u0119ci mikrokontrolera PIC16f877A.": "Podstawowe elementy pami\u0119ci mikrokontrolera PIC16f877A to:\n\n1. Flash - pami\u0119\u0107 programu, kt\u00f3ra przechowuje kod programu. Jest nieulotna i mo\u017ce zosta\u0107 zaktualizowana przez programowanie.\n\n2. EEPROM - elektrycznie kasowalna i programowalna pami\u0119\u0107 tylko do odczytu, kt\u00f3ra przechowuje dane, takie jak zmienne i sta\u0142e. Jest trwale zapisana nawet po od\u0142\u0105czeniu zasilania.\n\n3. SRAM - pami\u0119\u0107 RAM, kt\u00f3ra s\u0142u\u017cy jako szybka pami\u0119\u0107 robocza dla programu i danych, kt\u00f3re aktualnie s\u0105 u\u017cywane. Jest ulotna i traci dane po od\u0142\u0105czeniu zasilania.\n\n4. Special Function Registers (SFRs) - pami\u0119\u0107 specjalna, kt\u00f3ra przechowuje informacje o konfiguracji i stanu mikrokontrolera, takie jak status flagi, rejestry wej\u015bciowe/wyj\u015bciowe i liczniki zegarowe.\n\n5. Stos - obszar pami\u0119ci, kt\u00f3ry przechowuje dane stosowane w czasie wykonywania programu, takie jak zmienne lokalne i adresy powrotu z funkcji.\n\n6. Dane programowe - obszar w pami\u0119ci flash, kt\u00f3ry przechowuje dane liczbowe i tekstowe, takie jak sta\u0142e i tablice.\n\n7. We/wy porty - s\u0142u\u017c\u0105 do komunikacji z urz\u0105dzeniami zewn\u0119trznymi, takimi jak czujniki, przetworniki i wy\u015bwietlacze."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwoma fazami aktywnymi.\n\nSilnik krokowy to akcyjni element elektryczny, kt\u00f3ry przekszta\u0142ca sygna\u0142y elektryczne na ruch mechaniczny. Silnik krokowy sk\u0142ada si\u0119 z rdzenia magnetycznego i cewek elektromagnetycznych zamocowanych na jego obwodach. Ka\u017cda cewka jest pod\u0142\u0105czona do zewn\u0119trznego uk\u0142adu steruj\u0105cego, kt\u00f3ry dostarcza sygna\u0142 steruj\u0105cy.\n\nTryb z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105 polega na podawaniu na cewk\u0119 elektromagnetyczn\u0105 kolejno dw\u00f3ch sygna\u0142\u00f3w: jednego do zasilania cewki i drugiego do uziemienia cewki. Kiedy cewka jest zasilana, rdze\u0144 magnetyczny powoduje obr\u00f3t wa\u0142u silnika krokowego o ustalony k\u0105t (krok). Nast\u0119pnie sygna\u0142 do cewki jest od\u0142\u0105czany, a druga cewka jest zasilana, co powoduje kolejny krok.\n\nW trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi na ka\u017cd\u0105 z cewek jest podawany sygna\u0142 steruj\u0105cy. Pr\u0105d przep\u0142ywaj\u0105cy przez cewki zmienia polaryzacj\u0119 magnes\u00f3w i powoduje obr\u00f3t wa\u0142u o ustalony k\u0105t. W trybie tym ka\u017cdy krok jest rozdzielony na dwa etapy, a precyzja ruchu jest wy\u017csza.\n\nW obu przypadkach ruch silnika jest kontrolowany za pomoc\u0105 sygna\u0142\u00f3w steruj\u0105cych i umo\u017cliwia precyzyjne wykonywanie ruch\u00f3w o ustalonej wielko\u015bci kroku. Silniki krokowe wykorzystywane s\u0105 w urz\u0105dzeniach mechanicznych, takich jak drukarki, skanery, maszyny do obr\u00f3bki metali, a tak\u017ce w robotyce i automatyce przemys\u0142owej."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany czujnik mo\u017cna opisa\u0107 za pomoc\u0105 r\u00f3wnania r\u00f3\u017cniczkowego postaci:\n\n\\begin{equation}\n\\frac{d}{dt}y(t) = f(y(t), u(t), t)\n\\end{equation}\n\ngdzie:\n\n- $y(t)$ to wyj\u015bcie (odczyt) czujnika w czasie $t$,\n- $u(t)$ to wej\u015bcie (warunki pracy) czujnika w czasie $t$,\n- $f(y(t), u(t), t)$ to funkcja opisuj\u0105ca charakterystyk\u0119 czujnika.\n\nPrzyk\u0142adem funkcji opisuj\u0105cej charakterystyk\u0119 czujnika mo\u017ce by\u0107 r\u00f3wnanie opisuj\u0105ce zale\u017cno\u015b\u0107 mi\u0119dzy warto\u015bci\u0105 wyj\u015bciow\u0105 czujnika a warto\u015bci\u0105 mierzonej wielko\u015bci fizycznej. Dla przyk\u0142adu, czujnik temperatury mo\u017ce mie\u0107 zale\u017cno\u015b\u0107 opisan\u0105 r\u00f3wnaniem:\n\n\\begin{equation}\n\\frac{d}{dt}y(t) = k(T_{wew}(t) - y(t))\n\\end{equation}\n\ngdzie:\n\n- $k$ to wsp\u00f3\u0142czynnik proporcjonalno\u015bci czujnika,\n- $T_{wew}(t)$ to temperatura wewn\u0119trzna,\n- $y(t)$ to odczyt temperatury dokonany przez czujnik w czasie $t$.\n\nR\u00f3wnanie to m\u00f3wi nam, \u017ce warto\u015b\u0107 wyj\u015bciowa czujnika zale\u017cy od r\u00f3\u017cnicy temperatury mi\u0119dzy jego wn\u0119trzem a otoczeniem oraz od wsp\u00f3\u0142czynnika proporcjonalno\u015bci."
      }
    ],
    "#n": 20
  },
  "## Plik. 21": {
    "q&a": [
      {
        "Zad. 1 Opisz spos\u00f3b dzia\u0142ania stosu i instrukcje wykorzystywane do jego obs\u0142ugi w mikrokontrolerach klasy PIC18fxx2 i": "Stos w mikrokontrolerach klasy PIC18Fxx2 jest obs\u0142ugiwany przez dwa rejestry: SP i WREG.\n\nSP (Stack Pointer) przechowuje adres w pami\u0119ci, gdzie znajduje si\u0119 ostatni zapisany na stosie element. Pocz\u0105tkowo SP ustawiany jest na najwy\u017cszy adres w pami\u0119ci zaalokowanym na stos. Przy dodawaniu nowego elementu na stos SP jest dekrementowany, a przy zdejmowaniu elementu ze stosu SP jest inkrementowany.\n\nWREG (Working Register) to rejestr specjalnego przeznaczenia, kt\u00f3ry s\u0142u\u017cy do przechowywania warto\u015bci tymczasowych w trakcie wykonywania programu. W przypadku stosu, WREG s\u0142u\u017cy do przechowywania warto\u015bci, kt\u00f3ra ma zosta\u0107 dodana na stos lub pobrana ze stosu.\n\nInstrukcje wykorzystywane do obs\u0142ugi stosu w mikrokontrolerach klasy PIC18Fxx2 to:\n\n- PUSH: dodaje warto\u015b\u0107 z rejestru WREG na stos, dekrementuje SP\n- POP: pobiera warto\u015b\u0107 ze stosu i zapisuje j\u0105 do rejestru WREG, inkrementuje SP\n- CALL: dodaje adres powrotu na stos, dekrementuje SP, skacze do procedury\n- RETURN: pobiera adres powrotu ze stosu, inkrementuje SP, wraca do miejsca, z kt\u00f3rego zosta\u0142o wywo\u0142ane CALL\n\nDodatkowo, w mikrokontrolerach tej klasy stos wykorzystywany jest r\u00f3wnie\u017c do przechowywania rejestr\u00f3w kontekstu podczas przerwania, za kt\u00f3rych obs\u0142ug\u0119 odpowiada regu\u0142a LIFO (Last-In-First-Out), czyli ostatni zapisany element jest jako pierwszy pobierany ze stosu. Do obs\u0142ugi przerwa\u0144 stosowane s\u0105 specjalne instrukcje, takie jak:\n\n- PUSHALL: dodaje na stos wszystkie rejestry og\u00f3lnego przeznaczenia oraz rejestr statusu\n- POPALL: pobiera ze stosu warto\u015bci wszystkich rejestr\u00f3w og\u00f3lnego przeznaczenia oraz rejestr statusu\n\nDzi\u0119ki stosowi mo\u017cna \u0142atwo przekazywa\u0107 argumenty i zmienna lokalne mi\u0119dzy r\u00f3\u017cnymi cz\u0119\u015bciami programu, a tak\u017ce zapisywa\u0107 i odczytywa\u0107 adresy powrotu do i z procedur. Stos ma r\u00f3wnie\u017c zastosowanie w obs\u0142udze przerwa\u0144, gdzie pozwala na zachowanie kontekstu programu przed jego wykonaniem."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze P-N to z\u0142\u0105cze pomi\u0119dzy p\u00f3\u0142przewodnikami typu P (ang. positive) i N (ang. negative) o r\u00f3\u017cnych typach (typ P zawiera domieszk\u0119 akceptorow\u0105, a typ N zawiera domieszk\u0119 donorow\u0105).\n\nZjawiska zachodz\u0105ce w z\u0142\u0105czu P-N to:\n\n1. Bariera potencja\u0142u: W z\u0142\u0105czu P-N, p\u00f3\u0142przewodnik typu P i typu N tworz\u0105 barier\u0119 potencja\u0142u, kt\u00f3ra pozwala na kontrolowanie przep\u0142ywu pr\u0105du przez z\u0142\u0105cze. Elektrony w p\u00f3\u0142przewodniku N b\u0119d\u0105 sk\u0142ania\u0107 si\u0119 do ruchu w kierunku z\u0142\u0105cza, a dziura w p\u00f3\u0142przewodniku P b\u0119dzie sk\u0142ania\u0107 si\u0119 do ruchu w przeciwnym kierunku.\n\n2. Diodowy efekt prostowniczy: Z\u0142\u0105cza P-N mog\u0105 s\u0142u\u017cy\u0107 do prostowania pr\u0105du w obwodzie elektrycznym. Kiedy anoda diody jest pod\u0142\u0105czona do z\u0142\u0105cza typu P, a katoda diody jest pod\u0142\u0105czona do z\u0142\u0105cza typu N, pr\u0105d mo\u017ce p\u0142yn\u0105\u0107 tylko w jednym kierunku przez z\u0142\u0105cze, co powoduje, \u017ce dioda dzia\u0142a jak prostownik pr\u0105du.\n\n3. Efekt pojemno\u015bciowy: Z\u0142\u0105cza P-N s\u0105 wra\u017cliwe na zmiany napi\u0119cia, co powoduje zmian\u0119 pojemno\u015bci z\u0142\u0105cza w zale\u017cno\u015bci od napi\u0119cia na z\u0142\u0105czu. Pojemno\u015b\u0107 ta wp\u0142ywa na pr\u0105d przep\u0142ywaj\u0105cy przez z\u0142\u0105cze i mo\u017ce wprowadza\u0107 op\u00f3\u017anienia sygna\u0142u, co jest istotne w zastosowaniach elektronicznych.\n\n4. Efekt tunelowy: W z\u0142\u0105czach P-N mo\u017ce wyst\u0105pi\u0107 efekt tunelowy, w kt\u00f3rym elektrony s\u0105 transferowane przez barier\u0119 potencja\u0142u, co pozwala na przep\u0142yw pr\u0105du mi\u0119dzy z\u0142\u0105czami w kierunku przeciwnym do kierunku normalnego przep\u0142ywu pr\u0105du.\n\n5. Zjawisko rekombinacji: Przy dostatecznie du\u017cym zasilaniu, elektrony i dziury w z\u0142\u0105czu P-N mog\u0105 rekombinowa\u0107 ze sob\u0105, co powoduje generowanie ciep\u0142a i zmniejszenie wydajno\u015bci z\u0142\u0105cza."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dla uproszczenia za\u0142\u00f3\u017cmy, \u017ce dany jest czujnik temperatury, oznaczmy jego wyj\u015bcie przez T(t) [C]. R\u00f3wnanie r\u00f3\u017cniczkowe opisuj\u0105ce jego zachowanie mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co:\n\ndT/dt = q(T, t)\n\ngdzie q(T, t) jest funkcj\u0105 czasu i temperatury, opisuj\u0105c\u0105 spos\u00f3b, w jaki czujnik reaguje na zmiany temperatury w otoczeniu. Funkcja ta mo\u017ce mie\u0107 r\u00f3\u017cne postaci w zale\u017cno\u015bci od rodzaju czujnika i jego konstrukcji.\n\nRozwi\u0105zanie tego r\u00f3wnania differentyjnego pozwala okre\u015bli\u0107, jak temperatura na wyj\u015bciu czujnika zmienia si\u0119 w czasie, przy r\u00f3\u017cnych stanach pocz\u0105tkowych i warunkach zewn\u0119trznych (np. zmieniaj\u0105ca si\u0119 temperatura otoczenia). Mo\u017cna te\u017c na jego podstawie wyprowadzi\u0107 parametry charakteryzuj\u0105ce dzia\u0142anie czujnika, takie jak czas reakcji, czu\u0142o\u015b\u0107 czy dok\u0142adno\u015b\u0107 pomiaru."
      }
    ],
    "#n": 21
  },
  "## Plik. 22": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij znaczenie \ufb02ag kon\ufb01guracji w mikrokontrolerze PIC16f877A": "Flagi konfiguracji w mikrokontrolerze PIC16f877A s\u0142u\u017c\u0105 do ustawiania trybu pracy mikrokontrolera oraz konfiguracji jego peryferi\u00f3w. Flagi te s\u0105 przechowywane w specjalnej kom\u00f3rce pami\u0119ci o nazwie rejestru konfiguracji. Konfiguracja ta mo\u017ce by\u0107 ustawiana przez programist\u0119 lub automatycznie przez mikrokontroler w zale\u017cno\u015bci od potrzeb.\n\nPrzyk\u0142adowe ustawienia, kt\u00f3re mo\u017cna dokona\u0107 za pomoc\u0105 flag konfiguracyjnych to:\n- wyb\u00f3r trybu oscylatora (wewn\u0119trznego lub zewn\u0119trznego)\n- ustawienia trybu pracy uk\u0142adu taktuj\u0105cego (zegar synchroniczny lub asynchroniczny)\n- ustawienia przerwa\u0144 (w\u0142\u0105czanie i wy\u0142\u0105czanie poszczeg\u00f3lnych rodzaj\u00f3w przerwa\u0144)\n- konfiguracja uk\u0142ad\u00f3w peryferyjnych (np. modu\u0142u ADC)\n\nFlagi konfiguracyjne umo\u017cliwiaj\u0105 dostosowanie mikrokontrolera do konkretnych wymaga\u0144 aplikacji. Prawid\u0142owa konfiguracja pozwala na optymalne wykorzystanie zasob\u00f3w mikrokontrolera oraz zapewnia jego stabiln\u0105 i bezpieczn\u0105 prac\u0119."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 manipulatora SCARA.": "Aby obliczy\u0107 ruchliwo\u015b\u0107 manipulatora SCARA, nale\u017cy u\u017cy\u0107 wzoru:\n\nruchliwo\u015b\u0107 = liczba stopni swobody - liczba ogranicze\u0144\n\nLiczba stopni swobody to liczba niezale\u017cnych ruch\u00f3w, jakie mo\u017ce wykonywa\u0107 manipulator. W przypadku manipulatora SCARA s\u0105 to:\n\n- Ruch pionowy (z)\n- Ruch poziomy a (x)\n- Ruch poziomy b (y)\n- Obr\u00f3t ko\u0144c\u00f3wki (\u03b8)\n\nLiczba ogranicze\u0144 to liczba warunk\u00f3w, kt\u00f3re musz\u0105 by\u0107 spe\u0142nione, aby manipulator m\u00f3g\u0142 si\u0119 porusza\u0107. W przypadku manipulatora SCARA s\u0105 to:\n\n- Wi\u0105zka postaci ramienia (rami\u0119 nie mo\u017ce wygin\u0105\u0107)\n- Po\u0142\u0105czenie mi\u0119dzy ko\u0144c\u00f3wk\u0105 a punktem, gdzie osie ruchu x i y si\u0119 przecinaj\u0105 (ko\u0144c\u00f3wka nie mo\u017ce si\u0119 przemie\u015bci\u0107 wolno w pionie)\n\nW zwi\u0105zku z tym ruchliwo\u015b\u0107 manipulatora SCARA to:\n\nruchliwo\u015b\u0107 = 4 - 2 = 2\n\nManipulator SCARA ma ruchliwo\u015b\u0107 r\u00f3wn\u0105 2."
      },
      {
        "Zad. 3 Wyznacz (przybli\u017con\u0105) liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, dla kt\u00f3rego zebrano do\u015bwiadczalnie": "Liniowa charakterystyka wej\u015bciowo-wyj\u015bciowa czujnika to zale\u017cno\u015b\u0107 pomi\u0119dzy warto\u015bci\u0105 zmierzon\u0105 przez czujnik a warto\u015bci\u0105 wyj\u015bcia elektro\u0144skiego. Aby wyznaczy\u0107 liniow\u0105 charakterystyk\u0119, nale\u017cy zbada\u0107 pomiar dla r\u00f3\u017cnych warto\u015bci wej\u015bciowych i wyj\u015bciowych.\n\nNa przyk\u0142ad, je\u015bli zmierzono warto\u015bci napi\u0119cia wej\u015bciowego i odpowiadaj\u0105ce warto\u015bci napi\u0119cia wyj\u015bciowego czujnika, mo\u017cna przedstawi\u0107 te warto\u015bci na wykresie rozproszenia. Nast\u0119pnie, aby uzyska\u0107 charakterystyk\u0119 liniow\u0105, wykonuje si\u0119 regresj\u0119 liniow\u0105 dla punkt\u00f3w i rysuje si\u0119 prost\u0105, kt\u00f3ra najlepiej odzwierciedla zale\u017cno\u015b\u0107 mi\u0119dzy wej\u015bciem a wyj\u015bciem czujnika.\n\nPrzyk\u0142adowo, maj\u0105c takie pomiary:\n\nWej\u015bcie: 1, 2, 3, 4, 5\nWyj\u015bcie: 2, 4, 6, 8, 10\n\nMo\u017cemy przedstawi\u0107 je na wykresie rozproszenia i wykona\u0107 regresj\u0119 liniow\u0105:\n\nWykres: \n\n![Wykres_liniowy](https://i.imgur.com/hnTmtEd.png)\n\nRegresja liniowa: \n\n`y = 2x`\n\nProsta ta b\u0119dzie przybli\u017con\u0105 charakterystyk\u0105 liniow\u0105 czujnika."
      }
    ],
    "#n": 22
  },
  "## Plik. 23": {
    "q&a": [
      {
        "Zad. 1 Czym jest histereza w uk\u0142adach wej\u015bciowo-wyj\u015bciowych.": "Histereza to stan, w kt\u00f3rym warto\u015b\u0107 wyj\u015bciowa uk\u0142adu zale\u017cy nie tylko od warto\u015bci bie\u017c\u0105cej warto\u015bci wej\u015bciowej, ale tak\u017ce od poprzednich warto\u015bci wej\u015bciowych. Innymi s\u0142owy, uk\u0142ad mo\u017ce reagowa\u0107 na zmiany warto\u015bci wej\u015bciowej w spos\u00f3b op\u00f3\u017aniony lub skokowy w przypadku, gdy warto\u015b\u0107 wej\u015bciowa wypada poza pewne ustalone granice. W przypadku uk\u0142ad\u00f3w wej\u015bciowo-wyj\u015bciowych, histereza jest cz\u0119sto wykorzystywana w celu unikni\u0119cia falowania wyj\u015bciowego lub generowania sygna\u0142\u00f3w o praktycznym zastosowaniu. Histereza mo\u017ce r\u00f3wnie\u017c wp\u0142yn\u0105\u0107 na stabilno\u015b\u0107 i dok\u0142adno\u015b\u0107 pomiar\u00f3w w przypadku urz\u0105dze\u0144 pomiarowych lub regulacyjnych."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 (typowego) manipulatora ramieniowego.": "Nie jest mo\u017cliwe podanie jednoznacznej warto\u015bci ruchliwo\u015bci manipulatora ramieniowego, poniewa\u017c ruchliwo\u015b\u0107 zale\u017cy od wielu czynnik\u00f3w, takich jak liczba stopni swobody, d\u0142ugo\u015b\u0107 ramion, k\u0105ty ogranicze\u0144 ruchu, a tak\u017ce jako\u015b\u0107 i precyzja silnik\u00f3w oraz innych element\u00f3w steruj\u0105cych. Ruchliwo\u015b\u0107 mo\u017ce r\u00f3wnie\u017c r\u00f3\u017cni\u0107 si\u0119 w zale\u017cno\u015bci od trybu pracy robot\u00f3w (np. szybkie przemieszczanie, precyzyjne pozycjonowanie itp.). Og\u00f3lnie rzecz bior\u0105c, manipulatory ramieniowe charakteryzuj\u0105 si\u0119 wysok\u0105 ruchliwo\u015bci\u0105, co umo\u017cliwia im du\u017c\u0105 elastyczno\u015b\u0107 i wszechstronno\u015b\u0107 w wykonywaniu r\u00f3\u017cnych zada\u0144."
      }
    ],
    "#n": 23
  },
  "## Plik. 24": {
    "q&a": [
      {
        "Zad. 1 W jaki spos\u00f3b zjawisko piezoelektryczne jest wykorzystywane do budowy mikrofon\u00f3w.": "Mikrofony s\u0105 urz\u0105dzeniami, kt\u00f3re wykorzystuj\u0105 zjawisko piezoelektryczne do przekszta\u0142cenia fal d\u017awi\u0119kowych na sygna\u0142 elektryczny. Elementem piezoelektrycznym w mikrofonie jest ceramiczny kryszta\u0142. Kiedy fale d\u017awi\u0119kowe docieraj\u0105 do mikrofonu, kryszta\u0142 ulega odkszta\u0142ceniu, co prowadzi do powstania \u0142adunk\u00f3w elektrycznych na jego powierzchniach. \n\nTe \u0142adunki elektryczne s\u0105 nast\u0119pnie pobierane przez elektrody mikrofonu, kt\u00f3re przetwarzaj\u0105 je na sygna\u0142 elektryczny, kt\u00f3ry mo\u017ce by\u0107 zarejestrowany przez urz\u0105dzenia nagrywaj\u0105ce. W ten spos\u00f3b, kryszta\u0142 piezoelektryczny w mikrofonie s\u0142u\u017cy jako czujnik ruchu, przetwarzaj\u0105c drgania powietrza na sygna\u0142 elektryczny, kt\u00f3ry mo\u017ce by\u0107 wykorzystany do nagrywania d\u017awi\u0119ku. \n\nDzi\u0119ki prostocie i niezawodno\u015bci, mikrofony piezoelektryczne s\u0105 powszechnie stosowane w r\u00f3\u017cnych zastosowaniach, od nagrywania muzyki i g\u0142os\u00f3w, a\u017c po kontroli ha\u0142asu i detekcji wibracji w przemy\u015ble."
      },
      {
        "Zad. 2 Wykonaj obr\u00f3t punktu [1,1,1]o30\u25e6dooko\u0142a wektora [0.5,0.4,0.3]. Zamie\u015b\u0107 odpowiednie obliczenia.": "Obrotem punktu [1, 1, 1] o $30^\\circ$ wok\u00f3\u0142 wektora [0.5, 0.4, 0.3] nazywamy przekszta\u0142cenie, kt\u00f3re polega na znalezieniu punktu [x, y, z], kt\u00f3ry powstaje przez obr\u00f3cenie punktu [1, 1, 1] o k\u0105t $30^\\circ$ wok\u00f3\u0142 wektora [0.5, 0.4, 0.3], czyli:\n\n[x, y, z] = R([1, 1, 1], [0.5, 0.4, 0.3], $30^\\circ$)\n\nAby obliczy\u0107 wynikowe wsp\u00f3\u0142rz\u0119dne, skorzystamy z wzoru:\n\nR([1, 1, 1], [0.5, 0.4, 0.3], $30^\\circ$) = \n\ncos($30^\\circ$)([1, 1, 1] - proj[1, 1, 1] na [0.5, 0.4, 0.3]) +\n\n(1 - cos($30^\\circ$))[1, 1, 1] +\n\nsin($30^\\circ$)[0.5, 0.4, 0.3] x [1, 1, 1]\n\ngdzie proj[1, 1, 1] na [0.5, 0.4, 0.3] oznacza rzut punktu [1, 1, 1] na wektor [0.5, 0.4, 0.3], a x oznacza iloczyn wektorowy.\n\nObliczmy teraz poszczeg\u00f3lne sk\u0142adniki:\n\n- proj[1, 1, 1] na [0.5, 0.4, 0.3] = \n\n([1, 1, 1] * [0.5, 0.4, 0.3]) / ||[0.5, 0.4, 0.3]||^2 * [0.5, 0.4, 0.3] \n\n= (1.2 / 0.34) * [0.5, 0.4, 0.3]\n \n\u2248 [2.794, 2.235, 1.676]\n\n- [1, 1, 1] - proj[1, 1, 1] na [0.5, 0.4, 0.3] = [1, 1, 1] - [2.794, 2.235, 1.676] \u2248 [-1.794, -1.235, -0.676]\n\n- [0.5, 0.4, 0.3] x [1, 1, 1] = \n\n[(0.4*1-0.3*1), (-0.5*1+0.3*1), (0.5*1-0.4*1)] \n\n\u2248 [-0.1, -0.2, 0.1]\n\nWstawiaj\u0105c te warto\u015bci do wzoru otrzymujemy:\n\nR([1, 1, 1], [0.5, 0.4, 0.3], $30^\\circ$) = \n\ncos($30^\\circ$)[-1.794, -1.235, -0.676] +\n\n(1 - cos($30^\\circ$))[1, 1, 1] +\n\nsin($30^\\circ$)[-0.1, -0.2, 0.1]\n\n= [0.78, 0.56, 1.28]\n\nOstatecznie, punkt [1, 1, 1] obr\u00f3cony o $30^\\circ$ wok\u00f3\u0142 wektora [0.5, 0.4, 0.3] ma wsp\u00f3\u0142rz\u0119dne [0.78, 0.56, 1.28]."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie": "Zadanie kinematyki dla manipulatora z jednym \u0142\u0105czem obrotowym zamontowanym na bazie mo\u017cna rozwi\u0105za\u0107 przy u\u017cyciu podstawowych r\u00f3wna\u0144 kinematyki.\n\nNiech l b\u0119dzie d\u0142ugo\u015bci\u0105 \u0142\u0105cza manipulatora. Niech k\u0105t obrotu \u0142\u0105cza w stosunku do bazy b\u0119dzie oznaczony jako \u03b8.\n\nMo\u017cemy wyznaczy\u0107 pozycj\u0119 ko\u0144ca manipulatora (x, y) zgodnie ze wzorami:\n\nx = l * cos(\u03b8)\ny = l * sin(\u03b8)\n\nJe\u015bli znamy pozycj\u0119 ko\u0144ca manipulatora (x, y), mo\u017cemy wyznaczy\u0107 k\u0105t obrotu \u0142\u0105cza \u03b8 zgodnie ze wzorami:\n\n\u03b8 = atan2(y, x)\n\ngdzie atan2(y, x) to funkcja arcus tangens, kt\u00f3ra zwraca k\u0105t mi\u0119dzy osi\u0105 x a punktem (x, y) na p\u0142aszczy\u017anie.\n\nRozwi\u0105zanie kinematyki dla manipulatora z jednym \u0142\u0105czem obrotowym zamontowanym na bazie jest stosunkowo proste, poniewa\u017c manipulator mo\u017ce wykonywa\u0107 ruch tylko w jednej p\u0142aszczy\u017anie. Jednak w bardziej skomplikowanych manipulatorach z kilkoma \u0142\u0105czami i stopniami swobody rozwi\u0105zanie kinematyki staje si\u0119 znacznie bardziej z\u0142o\u017cone."
      }
    ],
    "#n": 24
  },
  "## Plik. 25": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania termopary i \u0142a\u0144cucha termicznego.": "Termopary s\u0105 urz\u0105dzeniami termometrycznymi sk\u0142adaj\u0105cymi si\u0119 z dw\u00f3ch przylegaj\u0105cych do siebie przewod\u00f3w r\u00f3\u017cnego materia\u0142u. Kiedy miejsca \u0142\u0105czenia tych przewod\u00f3w s\u0105 poddane r\u00f3\u017cnicom temperatur, to generuje to si\u0142\u0119 elektromotoryczn\u0105 (SEM). Wynikaj\u0105ce z tego napi\u0119cie jest proporcjonalne do r\u00f3\u017cnicy temperatur pomi\u0119dzy punktami po\u0142\u0105czenia przewod\u00f3w.\n\n\u0141a\u0144cuch termiczny natomiast to system, w kt\u00f3rym przenoszenie ciep\u0142a zachodzi sekwencyjnie. Sk\u0142ada si\u0119 on z element\u00f3w, kt\u00f3re s\u0105 po\u0142\u0105czone w serii lub r\u00f3wnolegle, przy czym przep\u0142yw ciep\u0142a zachodzi od element\u00f3w o wy\u017cszej temperaturze do ni\u017cszej. W \u0142a\u0144cuchu termicznym mamy do czynienia z r\u00f3\u017cnymi elementami, takimi jak materia\u0142y izolacyjne, przewody elektryczne lub pomiary ciep\u0142a oraz urz\u0105dzenia (np. piece lub ch\u0142odnice), kt\u00f3re zapewniaj\u0105 transfer energii cieplnej. Pomi\u0119dzy elementami mog\u0105 wyst\u0119powa\u0107 opory cieplne, kt\u00f3re wp\u0142ywaj\u0105 na przenikanie ciep\u0142a w \u0142a\u0144cuchu termicznym.\n\nW obu przypadkach kluczowym elementem jest przenoszenie energii, jednak w przypadku termopary energia jest przekazywana w postaci energii elektrycznej, a w \u0142a\u0144cuchu termicznym przenoszona jest energia cieplna."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "tekstu na wy\u015bwietlaczu HD44780.\n\nHD44780 to popularny sterownik wy\u015bwietlacza alfanumerycznego, kt\u00f3ry jest cz\u0119sto stosowany w r\u00f3\u017cnego rodzaju urz\u0105dzeniach elektronicznych, takich jak zegarki, termometry, czy komputery. Aby sterowa\u0107 wy\u015bwietlaczem HD44780, konieczne jest napisanie odpowiedniego programu w j\u0119zyku programowania, takim jak C czy C++. \n\nAby wy\u015bwietli\u0107 tekst na wy\u015bwietlaczu HD44780, nale\u017cy najpierw ustawi\u0107 tryb pracy wy\u015bwietlacza. Mo\u017cna to zrobi\u0107 za pomoc\u0105 komendy 0x20, kt\u00f3ra ustawia tryb pracy na 4-bitowy. Kolejnym krokiem jest ustawienie liczby wierszy i kolumn wy\u015bwietlacza za pomoc\u0105 komendy 0x08. Domy\u015blnie wy\u015bwietlacz HD44780 pracuje w trybie 2 wierszy i 16 kolumn, ale mo\u017cna to zmieni\u0107, ustawiaj\u0105c odpowiedni\u0105 warto\u015b\u0107 w rejestrze.\n\nNast\u0119pnie nale\u017cy wyczy\u015bci\u0107 wy\u015bwietlacz za pomoc\u0105 komendy 0x01, kt\u00f3ra wy\u015bwietla pusty ekran. Kolejnym krokiem jest ustawienie pozycji kursora za pomoc\u0105 komendy 0x80, kt\u00f3ra ustawia kursor w g\u00f3rnym lewym rogu wy\u015bwietlacza. Kursor jest punktem, w kt\u00f3rym b\u0119dzie wy\u015bwietlany kolejny znak.\n\nAby wy\u015bwietli\u0107 tekst na wy\u015bwietlaczu, nale\u017cy wys\u0142a\u0107 kolejne bajty z kodem ASCII ka\u017cdego znaku, kt\u00f3ry chcemy wy\u015bwietli\u0107. Mo\u017cna to zrobi\u0107 za pomoc\u0105 komendy 0x06, kt\u00f3ra ustawia tryb inkrementacji kursora, lub 0x07, kt\u00f3ra ustawia tryb dekrementacji kursora, w zale\u017cno\u015bci od preferencji programisty.\n\nKomendy te s\u0105 niezb\u0119dne do wy\u015bwietlenia tekstu na wy\u015bwietlaczu HD44780, ale istniej\u0105 r\u00f3wnie\u017c inne instrukcje, takie jak ustawienie trybu pracy wy\u015bwietlacza (domy\u015blnie tekst), ustawienie jasno\u015bci wy\u015bwietlacza, czy ustawienie kierunku przesuwania tekstu. Te dodatkowe instrukcje s\u0105 pomocne przy tworzeniu bardziej zaawansowanych aplikacji z wykorzystaniem wy\u015bwietlacza HD44780."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na": "osobnej podstawie.\n\nZa\u0142\u00f3\u017cmy, \u017ce manipulator znajduje si\u0119 w pozycji wyj\u015bciowej, czyli sk\u0142ada si\u0119 z jednego \u0142\u0105cza, kt\u00f3re jest r\u00f3wnoleg\u0142e do podstawy. Chcemy, aby manipulator przeszed\u0142 z pozycji wyj\u015bciowej do punktu o wsp\u00f3\u0142rz\u0119dnych (x,y,z).\n\nZacznijmy od ustalenia po\u0142o\u017cenia ramienia w pozycji wyj\u015bciowej. Za\u0142\u00f3\u017cmy, \u017ce d\u0142ugo\u015b\u0107 \u0142\u0105cza wynosi L, a k\u0105t mi\u0119dzy \u0142\u0105czem a osi\u0105 z wynosi 0 stopni. Zdefiniujmy te\u017c punkt-mocowanie na podstawie manipulatora jako punkt (0,0,0).\n\nJe\u015bli chcemy przenie\u015b\u0107 ramie na punkt o wsp\u00f3\u0142rz\u0119dnych (x,y,z), musimy okre\u015bli\u0107 odpowiedni k\u0105t mi\u0119dzy \u0142\u0105czem a osi\u0105 z. Mo\u017cemy to zrobi\u0107 korzystaj\u0105c z trygonometrii.\n\nZgodnie z w\u0142asno\u015bciami tr\u00f3jk\u0105ta prostok\u0105tnego, mo\u017cemy wyznaczy\u0107 k\u0105t mi\u0119dzy osi\u0105 z a po\u0142\u0105czeniem punktu (x,y,z) z punktem-mocowaniem. Aby to zrobi\u0107, musimy wyznaczy\u0107 d\u0142ugo\u015bci bok\u00f3w tr\u00f3jk\u0105ta.\n\nD\u0142ugo\u015b\u0107 boku przyleg\u0142ego do k\u0105ta wynosi y, a bok przeciwleg\u0142y wynosi sqrt(x^2 + z^2). Ostatecznie k\u0105t mi\u0119dzy osi\u0105 z a po\u0142\u0105czeniem punktu (x,y,z) z punktem-mocowaniem wynosi:\n\ntheta = arctan(y/sqrt(x^2 + z^2))\n\nGotowe! Teraz mo\u017cemy obr\u00f3ci\u0107 \u0142\u0105cze o wyliczony k\u0105t, aby przenie\u015b\u0107 manipulator do wybranego punktu."
      }
    ],
    "#n": 25
  },
  "## Plik. 26": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania kamery CCD.": "Kamera CCD (Charge-Coupled Device) dzia\u0142a w oparciu o zjawisko fotoelektryczne, kt\u00f3re polega na tym, \u017ce foton (cz\u0105stka \u015bwiat\u0142a) uderzaj\u0105c w materi\u0119 wybija z niej elektron. \n\nW kamerze CCD znajduje si\u0119 p\u0142ytka krzemowa pokryta ma\u0142ymi pikselami, na kt\u00f3rych padaj\u0105 fotony. Piksele te tworz\u0105 macierz, kt\u00f3ra sk\u0142ada si\u0119 z tysi\u0119cy wertykalnych i horyzontalnych rz\u0119d\u00f3w pikseli. Ka\u017cdy piksel zawiera warstw\u0119 p\u00f3\u0142przewodnika, kt\u00f3ra reaguje na fotony i wybija z niej elektrony. \n\nNast\u0119pnie elektrony s\u0105 przesuwane przez tzw. uk\u0142ad CCD (ang. charge-coupled device), czyli matryc\u0119 elektrod, kt\u00f3re tworz\u0105 elektryczne pola. Pole te przesuwaj\u0105 elektrony z jednego piksela do drugiego, zgodnie z zaprogramowanym skanowaniem obrazu. \n\nKiedy elektrony przemieszczaj\u0105 si\u0119 przez uk\u0142ad CCD, s\u0105 one przetwarzane na sygna\u0142 elektryczny, kt\u00f3ry odpowiada nat\u0119\u017ceniu \u015bwiat\u0142a, jakie pad\u0142o na piksel. Sygna\u0142y te s\u0105 konwertowane na wynikowy obraz, kt\u00f3ry wy\u015bwietla si\u0119 na ekranie monitora lub zapisuje na no\u015bniku danych. \n\nW wyniku dzia\u0142ania kamery CCD obraz jest generowany bardzo szybko \u2013 generowanie jednego klatki trwa zaledwie u\u0142amki sekundy \u2013 co czyni j\u0105 idealn\u0105 do zastosowa\u0144 wideo i fotograficznych."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy (ADC) to urz\u0105dzenie, kt\u00f3re przekszta\u0142ca sygna\u0142y analogowe na sygna\u0142y cyfrowe. Zadaniem konwertera jest pr\u00f3bkowanie i kwantyzacja sygna\u0142u analogowego. \n\nProces pr\u00f3bkowania polega na pobieraniu warto\u015bci sygna\u0142u w okre\u015blonych momentach czasowych, co pozwala na utworzenie ci\u0105g\u0142ego sygna\u0142u pr\u00f3bkowanego. Nast\u0119pnie sygna\u0142 jest poddawany kwantyzacji, co oznacza, \u017ce warto\u015bci sygna\u0142u s\u0105 zamieniane na konkretne warto\u015bci cyfrowe. \n\nKonwerter ADC sk\u0142ada si\u0119 z dw\u00f3ch g\u0142\u00f3wnych element\u00f3w: \n- bloku pr\u00f3bkowania i przechowywania warto\u015bci pr\u00f3bek sygna\u0142u \n- bloku kwantyzacji, kt\u00f3ry zamienia warto\u015bci sygna\u0142u na warto\u015bci cyfrowe.\n\nAby wykona\u0107 konwersj\u0119, konwerter ADC wymaga sygna\u0142u analogowego do przekszta\u0142cenia, czasu pr\u00f3bkowania, rozdzielczo\u015bci, tzn. liczby bit\u00f3w wyniku konwersji, i rozmiaru bufora pami\u0119ci dla przechowywania pr\u00f3bek sygna\u0142u.\n\nInstrukcje potrzebne do wykonania konwersji to przede wszystkim ustawienie parametr\u00f3w konwertera, takich jak rozdzielczo\u015b\u0107 i czas pr\u00f3bkowania, a nast\u0119pnie uruchomienie konwersji za pomoc\u0105 odpowiedniej funkcji lub instrukcji. Po zako\u0144czeniu konwersji nale\u017cy odczyta\u0107 wynik konwersji z wewn\u0119trznego rejestru konwertera ADC."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105-": "czonego z elementem ko\u0144cowym za pomoc\u0105 przegubu obrotowego.\n\nAby wyznaczy\u0107 parametry DH, musimy najpierw zdefiniowa\u0107 4 ramiona \u0142\u0105cz\u0105ce przeguby, wraz z uk\u0142adem ich osi:\n\n1. Ramie bazy: osia z obrotu bazy do obrotu ramienia.\n2. Ramie \u0142\u0105cz\u0105ce: osia z obrotu ramienia do obrotu przegubu.\n3. Ramie przegubu: osia z obrotu przegubu do obrotu ko\u0144c\u00f3wki.\n4. Ramie ko\u0144c\u00f3wki: osia z obrotu ko\u0144c\u00f3wki do punktu docelowego.\n\nKolejnym krokiem jest przypisanie sta\u0142ych d\u0142ugo\u015bci, k\u0105t\u00f3w i wsp\u00f3\u0142rz\u0119dnych dla ka\u017cdej osi. \n\n1. Ramie bazy:\n- d\u0142ugo\u015b\u0107: 0\n- k\u0105t: $\\theta_1$\n- wsp\u00f3\u0142rz\u0119dna: $(0, 0, 0)$\n\n2. Ramie \u0142\u0105cz\u0105ce:\n- d\u0142ugo\u015b\u0107: $a_1$\n- k\u0105t: 0\n- wsp\u00f3\u0142rz\u0119dna: $(0, 0, 0)$\n\n3. Ramie przegubu:\n- d\u0142ugo\u015b\u0107: $d_2$\n- k\u0105t: $\\theta_2$\n- wsp\u00f3\u0142rz\u0119dna: $(a_1, 0, 0)$\n\n4. Ramie ko\u0144c\u00f3wki:\n- d\u0142ugo\u015b\u0107: $d_3$\n- k\u0105t: 0\n- wsp\u00f3\u0142rz\u0119dna: $(a_1, 0, -d_2)$\n\nNast\u0119pnie, wyznaczamy macierze transformacji dla ka\u017cdego przegubu, kt\u00f3re s\u0142u\u017c\u0105 do przeliczenia wsp\u00f3\u0142rz\u0119dnych z jednego uk\u0142adu do drugiego. \n\nTransformacja pierwszego przegubu (ramie bazy do \u0142\u0105cz\u0105cego):\n$$\na = 0, \\quad\\alpha = 0,\\quad d = 0, \\quad \\theta = \\theta_1\n$$\n$$\nA_1 = \\begin{bmatrix}\n\\cos\\theta_1 & -\\sin\\theta_1 & 0 & 0\\\\\n\\sin\\theta_1 & \\cos\\theta_1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\n\nTransformacja drugiego przegubu (ramie \u0142\u0105cz\u0105ce do przegubu):\n$$\na = a_1, \\quad\\alpha = 0,\\quad d = 0, \\quad \\theta = 0\n$$\n$$\nA_2 = \\begin{bmatrix}\n1 & 0 & 0 & a_1\\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\n\nTransformacja trzeciego przegubu (przegub do ko\u0144c\u00f3wki):\n$$\na = 0, \\quad\\alpha = -\\frac{\\pi}{2},\\quad d = d_2, \\quad \\theta = \\theta_2\n$$\n$$\nA_3 = \\begin{bmatrix}\n\\cos\\theta_2 & -\\sin\\theta_2 & 0 & 0\\\\\n\\sin\\theta_2 & \\cos\\theta_2 & 0 & 0 \\\\\n0 & 0 & 1 & d_2 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\n\nTransformacja czwartego przegubu (ko\u0144c\u00f3wka do punktu docelowego):\n$$\na = 0, \\quad\\alpha = 0,\\quad d = d_3, \\quad \\theta = 0\n$$\n$$\nA_4 = \\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & -d_3 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n$$\n\nOstatecznie, wyznaczamy macierz przej\u015bcia od uk\u0142adu bazowego do uk\u0142adu ko\u0144cowego, \u0142\u0105cz\u0105c macierze transformacji:\n$$\nT = A_1 A_2 A_3 A_4\n$$\n\nMaj\u0105c macierz T, mo\u017cemy wyznaczy\u0107 po\u0142o\u017cenie ko\u0144c\u00f3wki w stosunku do bazy, korzystaj\u0105c z ostatniej kolumny T:\n$$\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz \\\\\n1 \\\\\n\\end{bmatrix}\n= T \\begin{bmatrix}\n0 \\\\\n0 \\\\\n0 \\\\\n1 \\\\\n\\end{bmatrix}\n$$\n\nGotowe parametry DH to:\n- $a_1$: odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 obrotu bazy a osi\u0105 obrotu ramienia\n- $d_2$: odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 obrotu przegubu a osi\u0105 obrotu ko\u0144c\u00f3wki\n- $d_3$: odleg\u0142o\u015b\u0107 mi\u0119dzy obrotem ko\u0144c\u00f3wki a punktem docelowym\n- $\\theta_1$: k\u0105t obrotu bazy\n- $\\theta_2$: k\u0105t obrotu przegubu\n- $\\alpha_1 = \\alpha_2 = 0$, poniewa\u017c oba przeguby s\u0105 obrotowe."
      }
    ],
    "#n": 26
  },
  "## Plik. 27": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter analogowo-cyfrowy (ADC) to urz\u0105dzenie elektroniczne, kt\u00f3re konwertuje sygna\u0142 analogowy na sygna\u0142 cyfrowy. Spos\u00f3b jego dzia\u0142ania opiera si\u0119 na pr\u00f3bkowaniu i kwantowaniu sygna\u0142u.\n\nPr\u00f3bkowanie polega na pobieraniu pr\u00f3bek sygna\u0142u wej\u015bciowego w regularnych odst\u0119pach czasowych. Odst\u0119p mi\u0119dzy pr\u00f3bkami okre\u015blany jest przez cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, wyra\u017con\u0105 w hertzach (Hz). Im wy\u017csza cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, tym wi\u0119ksza dok\u0142adno\u015b\u0107 i wierno\u015b\u0107 rekonstrukcji sygna\u0142u.\n\nKwantowanie polega na przypisywaniu ka\u017cdej pobranej pr\u00f3bce warto\u015bci binarnej, czyli w systemie dw\u00f3jkowym. W wyniku tego procesu sygna\u0142 analogowy zostaje zast\u0105piony ci\u0105giem warto\u015bci binarnych, kt\u00f3re reprezentuj\u0105 warto\u015bci sygna\u0142u w poszczeg\u00f3lnych chwilach czasu.\n\nObliczenia, jakie nale\u017cy wykona\u0107 w konwerterze analogowo-cyfrowym, zwi\u0105zane s\u0105 z procesem kwantowania, a dok\u0142adniej z wyznaczaniem poziomu sygna\u0142u. Warto\u015b\u0107 binarna opisuj\u0105ca pr\u00f3bk\u0119 sygna\u0142u jest uzyskiwana przez por\u00f3wnanie jej z okre\u015blonym poziomem progowym. Je\u017celi warto\u015b\u0107 sygna\u0142u jest wi\u0119ksza ni\u017c pr\u00f3g, to wynikiem kwantowania jest warto\u015b\u0107 binarna 1, a je\u015bli warto\u015b\u0107 sygna\u0142u jest mniejsza lub r\u00f3wna ni\u017c pr\u00f3g, to wynikiem kwantowania jest warto\u015b\u0107 binarna 0.\n\nWz\u00f3r na wyznaczanie warto\u015bci sygna\u0142u cyfrowego w zale\u017cno\u015bci od warto\u015bci analogowej i pr\u00f3g\u00f3w kwantyzacji wygl\u0105da nast\u0119puj\u0105co:\n\nVout = Q * [(Vana - Vmin) / (Vmax - Vmin)]\n\ngdzie:\n- Vout to warto\u015b\u0107 sygna\u0142u cyfrowego\n- Q to liczba poziom\u00f3w kwantyzacji, okre\u015blana przez liczb\u0119 bit\u00f3w u\u017cytych w procesie kwantowania\n- Vana to warto\u015b\u0107 sygna\u0142u analogowego\n- Vmin to minimalna warto\u015b\u0107 sygna\u0142u analogowego\n- Vmax to maksymalna warto\u015b\u0107 sygna\u0142u analogowego.\n\nWarto\u015b\u0107 Vout wyra\u017cona jest binarnie i opisuje warto\u015b\u0107 sygna\u0142u w danym czasie. Ca\u0142y proces odbywa si\u0119 bardzo szybko, w zale\u017cno\u015bci od cz\u0119stotliwo\u015bci pr\u00f3bkowania, umo\u017cliwiaj\u0105c szybk\u0105 i precyzyjn\u0105 cyfrow\u0105 analiz\u0119 sygna\u0142u analogowego."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "impedancja \u017ar\u00f3d\u0142a sygna\u0142u.\n\n![uk\u0142ad](https://i.imgur.com/WTriNof.png)\n\nAby obliczy\u0107 impedancj\u0119 zast\u0119pcz\u0105 uk\u0142adu, nale\u017cy skorzysta\u0107 z r\u00f3wnania:\n\nZ = R1 + Rs\n\nZ = 50\u2126 + 300\u2126\n\nZ = 350\u2126\n\nImpedancja zast\u0119pcza uk\u0142adu wynosi 350\u2126."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na bazie i": "z jednym przegubem obrotowym \u0142\u0105cz\u0105cym to \u0142\u0105cze z narz\u0119dziem ko\u0144cowym.\n\nParametry DH dla takiego manipulatora to:\n\n1. D\u0142ugo\u015b\u0107 \u0142\u0105cza pryzmatycznego: a1\n2. K\u0105t obrotu pierwszego przegubu: \u03b81\n3. Odleg\u0142o\u015b\u0107 mi\u0119dzy osiami obrotu pierwszego i drugiego przegubu: d2\n4. D\u0142ugo\u015b\u0107 narz\u0119dzia ko\u0144cowego: d4\n\nZgodnie z konwencj\u0105 DH, przyjmujemy nast\u0119puj\u0105ce ustalenia:\n\n- Osie z-0 i x-1 pokrywaj\u0105 si\u0119.\n- Osie x-0 i x-1 nachylone s\u0105 do siebie o k\u0105t \u03b11, mierz\u0105cy od osi x-0 do osi x-1 w kierunku przeciwnym do ruchu wskaz\u00f3wek zegara.\n- Osie z-1 i z-2 pokrywaj\u0105 si\u0119.\n- Osie x-1 i x-2 nachylone s\u0105 do siebie o k\u0105t \u03b12, mierz\u0105cy od osi x-1 do osi x-2 w kierunku przeciwnym do ruchu wskaz\u00f3wek zegara.\n\nWzory na parametry DH wygl\u0105daj\u0105 nast\u0119puj\u0105co:\n\na1 = d2 = 0 (bo mamy tylko jedno \u0142\u0105cze)\n\u03b81 = q1 (k\u0105t obrotu pierwszego przegubu r\u00f3wny k\u0105towi steruj\u0105cemu q1)\nd4 = 0 (bo narz\u0119dzie ko\u0144cowe jest zamocowane bezpo\u015brednio do drugiego przegubu)\n\nTabela parametr\u00f3w DH wygl\u0105da tak:\n\n| i | \u03b1i-1 | ai-1 | di   | \u03b8i   |\n|---|------|------|------|------|\n| 1 | 0    | a1   | 0    | \u03b81   |\n| 2 | 0    | 0    | d2   | 0    |\n| 3 | 0    | 0    | 0    | 0    |\n| 4 | 0    | 0    | d4   | 0    |\n\nOstatecznie, macierz transformacji homogenicznej z bazy do narz\u0119dzia ko\u0144cowego wygl\u0105da tak:\n\nT0_4 = T0_1 * T1_2 * T2_3 * T3_4\n\ngdzie T0_1, T1_2, T2_3 i T3_4 to macierze transformacji homogenicznej mi\u0119dzy kolejnymi po\u0142\u0105czeniami w manipulatorze, a T0_4 to macierz transformacji homogenicznej z bazy do narz\u0119dzia ko\u0144cowego."
      }
    ],
    "#n": 27
  },
  "## Plik. 28": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera cyfrowo-analogowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter cyfrowo-analogowy (DAC) to uk\u0142ad elektroniczny, kt\u00f3ry przetwarza sygna\u0142 cyfrowy na sygna\u0142 analogowy. DAC konwertuje ci\u0105g\u0142y sygna\u0142 binarny na odpowiadaj\u0105cy mu sygna\u0142 napi\u0119ciowy lub pr\u0105dowy, kt\u00f3ry mo\u017ce by\u0107 odczytywany przez dalsze urz\u0105dzenia.\n\nProces przetwarzania sygna\u0142u cyfrowego na analogowy w DAC polega na podstawieniu warto\u015bci liczby binarnej do wzoru na warto\u015b\u0107 napi\u0119cia lub pr\u0105du. Wz\u00f3r ten mo\u017ce by\u0107 r\u00f3\u017cny w zale\u017cno\u015bci od typu DAC, jednak w wi\u0119kszo\u015bci przypadk\u00f3w wykorzystuje si\u0119 wz\u00f3r liniowy:\n\nVout = (Vref * D) / 2^n\n\ngdzie:\n- Vout - napi\u0119cie analogowe wyj\u015bciowe DAC\n- Vref - warto\u015b\u0107 napi\u0119cia odniesienia, np. 2.5V\n- D - warto\u015b\u0107 cyfrowa wej\u015bciowa sygna\u0142u, od 0 do 2^n-1, gdzie n to liczba bit\u00f3w DAC\n- n - liczba bit\u00f3w DAC\n\nPodstawiaj\u0105c konkretne liczby, przyk\u0142adowo dla 8-bitowego DAC i warto\u015bci napi\u0119cia odniesienia Vref = 2.5V, otrzymujemy:\n\nVout = (2.5V * D) / 2^8\n\nW takim przypadku warto\u015b\u0107 napi\u0119cia analogowego wyj\u015bciowego b\u0119dzie si\u0119 zmienia\u0107 od 0V do 2.5V z krokiem 9.77 mV, gdy warto\u015b\u0107 D zwi\u0119ksza si\u0119 od 0 do 255.\n\nW skr\u00f3cie, DAC konwertuje warto\u015bci cyfrowe na odpowiadaj\u0105ce im warto\u015bci analogowe wed\u0142ug okre\u015blonego wzoru."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwiema fazami aktywnymi.\n\nSilnik krokowy to rodzaj silnika elektrycznego, kt\u00f3ry obraca si\u0119 o sta\u0142y, okre\u015blony k\u0105t za ka\u017cdym razem, gdy do niego podajemy impuls elektryczny. Silnik krokowy mo\u017ce dzia\u0142a\u0107 w r\u00f3\u017cnych trybach, w tym trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105 oraz w trybie z pe\u0142nym krokiem i dwiema fazami aktywnymi. \n\nW trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, silnik krokowy jest zasilany jednym impulsowym sygna\u0142em elektrycznym w jednej z jego faz, a pozosta\u0142e trzy fazy s\u0105 pozostawione w stanie martwym. Po zastosowaniu sygna\u0142u elektrycznego, silnik krokowy obraca si\u0119 o jeden pe\u0142ny krok (ang. full step) w jednym kierunku, a nast\u0119pnie traci moment obrotowy, a\u017c do momentu przes\u0142ania kolejnego impulsu elektrycznego. Ten tryb jest najprostszym i najszybszym sposobem na kontrolowanie silnika krokowego, ale ma nisk\u0105 precyzj\u0119 i gorsz\u0105 skuteczno\u015b\u0107 energetyczn\u0105.\n\nW trybie z pe\u0142nym krokiem i dwiema fazami aktywnymi, silnik krokowy jest zasilany dwoma sygna\u0142ami elektrycznymi, kt\u00f3re zmieniaj\u0105 si\u0119 na przemian, aktywuj\u0105c kolejno dwie fazy silnika krokowego. Po podaniu pierwszego sygna\u0142u, silnik obraca si\u0119 o po\u0142ow\u0119 kroku (ang. half step) w jednym kierunku, natomiast po podaniu drugiego sygna\u0142u silnik obraca si\u0119 o kolejn\u0105 po\u0142ow\u0119 kroku w przeciwnym kierunku. Ten tryb zapewnia wi\u0119ksz\u0105 precyzj\u0119 i bardziej p\u0142ynny ruch, ale wymaga zastosowania bardziej skomplikowanego algorytmu sterowania, co mo\u017ce zwi\u0119kszy\u0107 koszty i z\u0142o\u017cono\u015b\u0107 projektu."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "$$\\frac{d}{dt}y(t) = f(u(t),y(t))$$\ngdzie:\n- $y(t)$ - warto\u015b\u0107 mierzonej wielko\u015bci w czasie $t$\n- $u(t)$ - warto\u015b\u0107 zmiennej wp\u0142ywaj\u0105cej na czujnik w czasie $t$\n- $f$ - funkcja opisuj\u0105ca zale\u017cno\u015b\u0107 pomi\u0119dzy $u(t)$ i $y(t)$.\n\nCzujnik mo\u017ce mie\u0107 r\u00f3\u017cne typy reakcji na zmiany $u(t)$, na przyk\u0142ad:\n- Je\u015bli czujnik ciep\u0142a rejestruje wzrost temperatury, to $f$ b\u0119dzie zale\u017ca\u0142o od r\u00f3\u017cnicy temperatury mi\u0119dzy czujnikiem a otoczeniem.\n- Czujnik wilgotno\u015bci mo\u017ce mie\u0107 bardziej skomplikowan\u0105 reakcj\u0119, zale\u017cn\u0105 od temperatury, ci\u015bnienia i ilo\u015bci wilgoci w powietrzu.\n- Czujnik ci\u015bnienia mo\u017ce dzia\u0142a\u0107 na zasadzie zamkni\u0119tego systemu hydraulicznego, gdzie $u(t)$ wp\u0142ywa na ci\u015bnienie w uk\u0142adzie, a $f$ jest zwi\u0105zane z w\u0142a\u015bciwo\u015bciami cieczy lub gazu wewn\u0105trz czujnika.\n\nCzujniki opisane r\u00f3wnaniem r\u00f3\u017cniczkowym s\u0105 cz\u0119sto stosowane w systemach regulacji i automatyce, gdzie ich reakcja na sygna\u0142y zewn\u0119trzne jest kluczowa dla utrzymania stabilnego dzia\u0142ania systemu."
      }
    ],
    "#n": 28
  },
  "## Plik. 29": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij zastosowanie Supervisor-a w oprogramowaniu Webots. Poka\u017c jak i jakie instrukcje s\u0142u\u017c\u0105 do odczytywania": "i modyfikowania parametr\u00f3w robota.\n\nSupervisor w oprogramowaniu Webots to narz\u0119dzie, kt\u00f3re umo\u017cliwia u\u017cytkownikowi kontrolowanie symulacji i interakcj\u0119 z robotami. Dzi\u0119ki temu narz\u0119dziu u\u017cytkownik mo\u017ce modyfikowa\u0107 ustawienia symulacji i parametry robota w czasie jej trwania.\n\nAby odczyta\u0107 lub zmodyfikowa\u0107 parametry robota w Webotsie, nale\u017cy u\u017cy\u0107 Specyfikacji Dynamicznej Robota (Robot Dynamic Specification). S\u0142u\u017cy do tego klasa Robot (Supervisor), kt\u00f3ra reprezentuje robota w symulacji. Aby uzyska\u0107 dost\u0119p do specyfikacji danego robota, nale\u017cy wywo\u0142a\u0107 metod\u0119 getRobot() na obiekcie Supervisor.\n\nPrzyk\u0142adowy kod s\u0142u\u017c\u0105cy do odczytania pozycji robota (np. jego wsp\u00f3\u0142rz\u0119dnych x, y, z) wygl\u0105da nast\u0119puj\u0105co:\n\n```python\nfrom controller import Robot\n\n# Inicjowanie robota\nrobot = Robot()\n\n# Pobranie pozycji robota\nposition = robot.getFromDef(\"myRobot\").getPosition()\n\n# Wy\u015bwietlenie pozycji\nprint(\"Pozycja robota: \", position)\n```\n\nNatomiast przyk\u0142adowy kod s\u0142u\u017c\u0105cy do zmiany pr\u0119dko\u015bci robota wygl\u0105da nast\u0119puj\u0105co:\n\n```python\nfrom controller import Robot\n\n# Inicjowanie robota\nrobot = Robot()\n\n# Pobieranie kana\u0142u pr\u0119dko\u015bci silnika\nleftMotor = robot.getDevice(\"left wheel motor\")\nrightMotor = robot.getDevice(\"right wheel motor\")\n\n# Ustawienie pr\u0119dko\u015bci robota\nleftMotor.setVelocity(10)\nrightMotor.setVelocity(10)\n```\n\nW powy\u017cszym kodzie pobierane s\u0105 kana\u0142y pr\u0119dko\u015bci silnik\u00f3w lewego i prawego ko\u0142a, a nast\u0119pnie ustawiana jest pr\u0119dko\u015b\u0107 obrotowa obu k\u00f3\u0142 na poziomie 10 rad/s."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze P-N to po\u0142\u0105czenie dw\u00f3ch typ\u00f3w p\u00f3\u0142przewodnik\u00f3w: p\u00f3\u0142przewodnika typu P, w kt\u00f3rym dominuj\u0105 no\u015bniki dziur, oraz p\u00f3\u0142przewodnika typu N, w kt\u00f3rym dominuj\u0105 no\u015bniki elektronowe. W wyniku po\u0142\u0105czenia tych dw\u00f3ch p\u00f3\u0142przewodnik\u00f3w powstaje z\u0142\u0105cze, w kt\u00f3rym dochodzi do zjawisk elektrycznych.\n\nG\u0142\u00f3wne zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N to:\n\n1. Zjawisko dyfuzyjne - wynika z gradientu st\u0119\u017ce\u0144 no\u015bnik\u00f3w na granicy z\u0142\u0105cza. No\u015bniki mniejszej koncentracji dyfunduj\u0105 z obszaru o wi\u0119kszej koncentracji do obszaru o mniejszej st\u0119\u017ceniu. No\u015bniki elektronowe dyfunduj\u0105 z obszaru typu N do obszaru typu P, natomiast no\u015bniki dziur dyfunduj\u0105 z obszaru typu P do obszaru typu N.\n\n2. Zjawisko rekombinacji - co do zasady mo\u017cliwa jest rekombinacja zar\u00f3wno no\u015bnik\u00f3w elektronowych, jak i dziurowych. W wyniku rekombinacji ka\u017cda para no\u015bnik\u00f3w zostaje zneutralizowana, a energia elektron\u00f3w i dziur uwalnia si\u0119 w postaci foton\u00f3w.\n\n3. Zjawisko tworzenia pola elektrostatycznego - na granicy P-N pojawia si\u0119 pole elektrostatyczne, kt\u00f3re wynika z r\u00f3\u017cnicy potencja\u0142\u00f3w mi\u0119dzy obszarem o przewadze no\u015bnik\u00f3w typu P a obszarem o przewadze no\u015bnik\u00f3w typu N.\n\n4. Zjawisko przebicia - je\u015bli przy\u0142o\u017cymy do z\u0142\u0105cza zewn\u0119trzne napi\u0119cie zbyt du\u017ce, to dochodzi do przebicia z\u0142\u0105cza, co oznacza, \u017ce pr\u0105d zaczyna p\u0142yn\u0105\u0107 bez kontroli przez z\u0142\u0105cze. W przypadku przebicia z\u0142\u0105cza mo\u017ce doj\u015b\u0107 do uszkodzenia uk\u0142adu elektronicznego."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": ":\n\n$\\frac{dy}{dt}=-ky$\n\ngdzie $y$ oznacza warto\u015b\u0107 czujnika w czasie $t$, a $k$ to sta\u0142a proporcjonalno\u015bci.\n\nR\u00f3wnanie to opisuje prosty model zaniku sygna\u0142u czujnika w czasie. Im wi\u0119ksza warto\u015b\u0107 $k$, tym szybciej nast\u0119puje zanik sygna\u0142u. Rozwi\u0105zaniem tego r\u00f3wnania jest:\n\n$y(t)=y_0e^{-kt}$\n\ngdzie $y_0$ to pocz\u0105tkowa warto\u015b\u0107 czujnika.\n\nPrzyk\u0142adowo, je\u015bli $y_0=10$ i $k=0,1$, to po up\u0142ywie jednej minuty warto\u015b\u0107 czujnika spadnie do oko\u0142o 6,7. Po dziesi\u0119ciu minutach b\u0119dzie ona ju\u017c tylko oko\u0142o 0,004."
      }
    ],
    "#n": 29
  },
  "## Plik. 30": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij poj\u0119cie przekszta\u0142ce\u0144 jednorodnych.": "Przekszta\u0142cenia jednorodne to takie przekszta\u0142cenia geometryczne, kt\u00f3re zachowuj\u0105 proporcje i proporcjonalno\u015b\u0107 mi\u0119dzy elementami. Innymi s\u0142owy, je\u015bli przekszta\u0142cenie jednorodne zmienia d\u0142ugo\u015b\u0107 jednej linii, to zmienia ono r\u00f3wnie\u017c d\u0142ugo\u015b\u0107 pozosta\u0142ych linii w proporcjonalny spos\u00f3b. Przyk\u0142adem przekszta\u0142cenia jednorodnego jest homotetia, czyli przekszta\u0142cenie polegaj\u0105ce na zmianie skali ka\u017cdego punktu wzgl\u0119dem pewnego punktu, tak aby zachowa\u0107 proporcje. Innymi przyk\u0142adami s\u0105 przesuni\u0119cie, obr\u00f3t i odbicie lustrzane. Przekszta\u0142cenia jednorodne s\u0105 wa\u017cne w matematyce, a tak\u017ce w fizyce, gdzie opisuj\u0105 zachowanie si\u0119 obiekt\u00f3w w r\u00f3\u017cnych skalach."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 manipulatora SCARA.": "Ruchliwo\u015b\u0107 manipulatora SCARA mo\u017cna obliczy\u0107 za pomoc\u0105 r\u00f3wnania:\n\nruchliwo\u015b\u0107 = liczba stopni swobody - liczba ogranicze\u0144\n\nSCARA ma 4 stopnie swobody, co oznacza, \u017ce \u200b\u200bma mo\u017cliwo\u015b\u0107 przemieszczania si\u0119 w czterech niezale\u017cnych kierunkach. Ponadto, manipulator SCARA ma pewne ograniczenia w pewnych obszarach, takie jak k\u0105t nachylenia ramienia i ograniczenia ruchu osi obrotowych.\n\nOstatecznie, ruchliwo\u015b\u0107 manipulatora SCARA wynosi 4 - 2 = 2.\n\nJest to spowodowane ograniczeniem przesuwu wzd\u0142u\u017c osi Z (pionowej) i obracaj\u0105cym ruchu ramienia manipulatora wok\u00f3\u0142 osi X (poziomej)."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym:\n\ndy/dt + 2y = 5u\n\nGdzie y oznacza wyj\u015bcie czujnika (np. napi\u0119cie wyj\u015bciowe), u oznacza wej\u015bcie czujnika (np. warto\u015b\u0107 mierzonej wielko\u015bci) a t czas.\n\nR\u00f3wnanie to opisuje reakcj\u0119 czujnika na zmiany warto\u015bci mierzonej wielko\u015bci. Im wi\u0119ksza warto\u015b\u0107 wej\u015bcia (u), tym wi\u0119ksze wyj\u015bcie (y). Jednocze\u015bnie, czujnik reaguje z op\u00f3\u017anieniem (z op\u00f3\u017anieniem r\u00f3wnym 2/k, gdzie k to sta\u0142a czasowa czujnika), co wynika z wyst\u0119powania pierwszej pochodnej w r\u00f3wnaniu r\u00f3\u017cniczkowym.\n\nR\u00f3wnanie to mo\u017cna rozwi\u0105za\u0107, aby uzyska\u0107 funkcj\u0119 opisuj\u0105c\u0105 wyj\u015bcie czujnika w czasie. W praktyce, czujnik taki mo\u017ce by\u0107 wykorzystywany np. do pomiaru temperatury, wilgotno\u015bci lub ci\u015bnienia."
      }
    ],
    "#n": 30
  },
  "## Plik. 31": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij przeznaczenie poszczeg\u00f3lnych bit\u00f3w rejestru STATUS.": "Rejestr STATUS jest rejestrem flagowym, kt\u00f3ry informuje o r\u00f3\u017cnych warunkach w trakcie dzia\u0142ania procesora. Poszczeg\u00f3lne bity maj\u0105 nast\u0119puj\u0105ce przeznaczenie:\n\n- Bit 0 (C) - carry flag, informuje o wyst\u0105pieniu przeniesienia lub po\u017cyczki podczas operacji arytmetycznych.\n- Bit 1 (DC) - digit carry flag, informuje o wyst\u0105pieniu przeniesienia lub po\u017cyczki w cz\u0119\u015bci ni\u017cszej czterech bit\u00f3w podczas operacji arytmetycznych.\n- Bit 2 (Z) - zero flag, informuje o wyst\u0105pieniu warto\u015bci zero w wyniku operacji.\n- Bit 3 (PD) - power-down flag, informuje o trybie oszcz\u0119dzania energii zwi\u0105zanym z wy\u0142\u0105czeniem procesora/rejestru RAm.\n- Bit 4 (TO) - timeout flag, informuje o przekroczeniu czasu wykonania danej operacji.\n- Bit 5 (R) - reserved, nieu\u017cywany bit.\n- Bit 6 (I) - interrupt flag, informuje o zezwoleniu (I = 1)/zablokowaniu (I = 0) na obs\u0142ug\u0119 przerwa\u0144.\n- Bit 7 (N) - negative flag, informuje o wyniku operacji o ujemnej warto\u015bci."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 (typowego) manipulatora ramieniowego.": "Ruchliwo\u015b\u0107 manipulatora ramieniowego zale\u017cy od liczby stopni swobody, czyli liczby niezale\u017cnych ruch\u00f3w, jakie mo\u017ce wykonywa\u0107. \n\nTypowy manipulator ramieniowy ma 6 stopni swobody, co oznacza, \u017ce mo\u017ce wykonywa\u0107 sze\u015b\u0107 niezale\u017cnych ruch\u00f3w, takich jak obr\u00f3t wok\u00f3\u0142 osi, przesuni\u0119cie wzd\u0142u\u017c osi, ruch w g\u00f3re i w d\u00f3\u0142, itp.\n\nDlatego ruchliwo\u015b\u0107 typowego manipulatora ramieniowego wynosi 6."
      },
      {
        "Zad. 3 Wyznacz (przybli\u017con\u0105) liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, dla kt\u00f3rego zebrano do\u015bwiadczalnie": "niepewno\u015bci pomiarowej. Bez innych danych nie jest mo\u017cliwe wyznaczenie charakterystyki wej\u015bciowo-wyj\u015bciowej czujnika. Potrzebne s\u0105 przynajmniej warto\u015bci mierzonych wielko\u015bci oraz ich zwi\u0105zki ze sob\u0105, aby m\u00f3c dokona\u0107 analizy i wyznaczy\u0107 charakterystyk\u0119."
      }
    ],
    "#n": 31
  },
  "## Plik. 32": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci programu w mikrokontrolerze PIC16f877A.": "W mikrokontrolerze PIC16f877A dost\u0119pne s\u0105 r\u00f3\u017cne sposoby adresacji pami\u0119ci, w tym:\n\n1. Adresowanie bezpo\u015brednie \u2013 odwo\u0142anie do konkretnego adresu pami\u0119ci, np. MOVF 0x20, W oznacza przes\u0142anie zawarto\u015bci rejestru na pozycji pami\u0119ci 0x20 do rejestru W.\n\n2. Adresowanie przez rejestr poczw\u00f3rny \u2013 u\u017cywany do odwo\u0142ywania si\u0119 do pozycji pami\u0119ci odpowiadaj\u0105cej warto\u015bci przechowywanej w czterech rejestrach, np. MOVF FSR, W oznacza przes\u0142anie zawarto\u015bci pozycji w pami\u0119ci, na kt\u00f3r\u0105 wskazuje rejestr FSR, do rejestru W.\n\n3. Adresowanie przez rejestr na podstawie offsetu \u2013 odwo\u0142anie do adresu pami\u0119ci z u\u017cyciem adresu bazowego i offsetu, np. MOVLW 0x02, ADDWF PORTB, F oznacza dodanie warto\u015bci 2 do zawarto\u015bci rejestru PORTB.\n\n4. Adresowanie przez rejestr ze znacznikiem \u2013 u\u017cywane g\u0142\u00f3wnie w przypadku odwo\u0142ywania si\u0119 do pozycji pami\u0119ci tablicowej, np. MOVF TABLAT, W oznacza przes\u0142anie zawarto\u015bci pozycji w tablicy do rejestru W.\n\n5. Adresowanie bezpo\u015brednie z indeksem \u2013 odwo\u0142anie do konkretnego adresu pami\u0119ci z wykorzystaniem indeksu, np. MOVF 0x20+INDF, W oznacza przes\u0142anie zawarto\u015bci adresu pami\u0119ci wskazywanego przez zawarto\u015b\u0107 rejestru INDF o warto\u015bci 0x20 do rejestru W.\n\n6. Adresowanie przez rejestr indirekcyjny \u2013 odwo\u0142anie do adresu pami\u0119ci wskazywanego przez zawarto\u015b\u0107 rejestru, np. MOVF INDF, W oznacza przes\u0142anie zawarto\u015bci adresu pami\u0119ci wskazywanego przez rejestr INDF do rejestru W."
      },
      {
        "Zad. 2 Wykonaj obr\u00f3t punktu [1,1,1]o30\u25e6dooko\u0142a wektora [0.5,0.4,0.3]. Zamie\u015b\u0107 odpowiednie obliczenia.": "W celu wykonania obr\u00f3t punktu o k\u0105t 30\u25e6 wok\u00f3\u0142 wektora [0.5,0.4,0.3] mo\u017cemy skorzysta\u0107 z formu\u0142 Rodriguesa:\n\nr' = r cos(\u03b8) + (k x r) sin(\u03b8) + k(k \u00b7 r)(1 - cos(\u03b8))\n\ngdzie:\nr - punkt poddawany obrotowi [1,1,1]\n\u03b8 - k\u0105t obrotu (30\u25e6 w radianach = \u03c0/6)\nk - wektor normalny do p\u0142aszczyzny obrotu, czyli [0.5,0.4,0.3]/\u221a(0.5\u00b2+0.4\u00b2+0.3\u00b2) = [0.576,0.461,0.691]\n\nTeraz podstawiaj\u0105c warto\u015bci do wzoru otrzymujemy:\n\nr' = [1,1,1] cos(\u03c0/6) + ([0.576,0.461,0.691] x [1,1,1]) sin(\u03c0/6) + [0.576,0.461,0.691]([0.576,0.461,0.691] \u00b7 [1,1,1])(1 - cos(\u03c0/6))\n\nr' = [1,1,1] \u221a3/2 + [0.154,-0.336,0.214] \u221a3/2 + [0.235,0.188,0.281] 1/2\n\nr' = [1.212,0.775,1.259]\n\nOdpowied\u017a: obr\u00f3cony punkt ma wsp\u00f3\u0142rz\u0119dne [1.212,0.775,1.259]."
      }
    ],
    "#n": 32
  },
  "## Plik. 33": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij sposoby adresacji pami\u0119ci danych w mikrokontrolerze PIC16f877A.": "Mikrokontroler PIC16f877A ma architektur\u0119 von Neumanna, co oznacza, \u017ce zar\u00f3wno dane, jak i instrukcje przechowywane s\u0105 w jednej pami\u0119ci. W zwi\u0105zku z tym adresowanie pami\u0119ci danych odbywa si\u0119 za pomoc\u0105 tych samych adres\u00f3w, co adresowanie instrukcji.\n\nSposoby adresacji pami\u0119ci danych w mikrokontrolerze PIC16f877A to:\n\n1. Adresowanie bezpo\u015brednie - polega na bezpo\u015brednim okre\u015bleniu adresu kom\u00f3rki pami\u0119ci danych, do kt\u00f3rej chcemy si\u0119 odwo\u0142a\u0107. Adres ten zapisywany jest bezpo\u015brednio po instrukcji, np. MOVF 0x20, w kt\u00f3rej 0x20 to adres kom\u00f3rki pami\u0119ci.\n\n2. Adresowanie po\u015brednie - wykorzystuje rejestr wska\u017anikowy (ang. pointer) do przechowywania adresu danej kom\u00f3rki pami\u0119ci. Rejestr ten mo\u017ce przyj\u0105\u0107 warto\u015b\u0107 z dowolnej innej kom\u00f3rki pami\u0119ci, co umo\u017cliwia adresowanie danych, kt\u00f3rych adresy nie s\u0105 znane na etapie pisania programu. Przyk\u0142adem instrukcji z takim sposobem adresacji jest MOVF FSR, w kt\u00f3rej FSR to rejestr wska\u017anikowy.\n\n3. Adresowanie przez stron\u0119 - polega na okre\u015bleniu adresu pami\u0119ci na podstawie warto\u015bci znajduj\u0105cej si\u0119 w rejestrze STATUS. Adres ten zawsze startuje od adresu pocz\u0105tkowego danej strony pami\u0119ci. Przyk\u0142adem instrukcji z takim sposobem adresacji jest MOVF 0x05, 0x00, w kt\u00f3rej 0x05 to numer strony pami\u0119ci.\n\n4. Adresowanie bezpo\u015brednie z przesuni\u0119ciem - umo\u017cliwia adresowanie danych w spos\u00f3b wzgl\u0119dny do adresu bazowego. Adres przesuni\u0119cia jest okre\u015blany bezpo\u015brednio po instrukcji, a warto\u015b\u0107 przesuni\u0119cia jest przechowywana w jednym z rejestr\u00f3w wewn\u0119trznych mikrokontrolera. Przyk\u0142adem instrukcji z tym sposobem adresacji jest MOVF 0x20, ACCESS, w kt\u00f3rej ACCESS oznacza adresowanie wzgl\u0119dne.\n\n5. Adresowanie po\u015brednie z przesuni\u0119ciem - po\u0142\u0105czenie adresowania po\u015bredniego z przesuni\u0119ciem. Polega na okre\u015bleniu adresu pami\u0119ci przez zsumowanie warto\u015bci przechowywanej w rejestrze wska\u017anikowym i warto\u015bci przesuni\u0119cia przechowywanej w jednym z rejestr\u00f3w wewn\u0119trznych. Przyk\u0142adem instrukcji z tym sposobem adresacji jest MOVF INDF, 0x01, w kt\u00f3rej INDF to rejestr wska\u017anikowy, a 0x01 to warto\u015b\u0107 przesuni\u0119cia."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "Tekstu na wy\u015bwietlaczu HD44780 mo\u017cna programowa\u0107 za pomoc\u0105 mikrokontrolera lub mikroprocesora. Do po\u0142\u0105czenia z wy\u015bwietlaczem wystarczy zwykle kilka przewod\u00f3w przy u\u017cyciu interfejsu szeregowego, takiego jak interfejs I2C lub SPI.\n\nKa\u017cdy wy\u015bwietlacz HD44780 jest podzielony na 80 pikseli sk\u0142adaj\u0105cych si\u0119 z 5x8 punkt\u00f3w. S\u0105 one niezale\u017cne, poniewa\u017c maj\u0105 w\u0142asne kontrolery, wi\u0119c mo\u017cna wy\u015bwietli\u0107 r\u00f3\u017cne znaki lub komunikaty na r\u00f3\u017cnych pozycjach na ekranie.\n\nNajwa\u017cniejsze instrukcje programowania wy\u015bwietlacza HD44780 to:\n- W\u0142\u0105cz wy\u015bwietlacz: 0x0E lub 0x0C\n- Ustaw tryb kursora: 0x06 lub 0x04\n- Ustaw tryb pracy: 0x38\n- Ustaw pozycj\u0119 kursora: 0x80 + pozycja(pomi\u0119dzy 0 a 15); 0xC0 + pozycja(pomi\u0119dzy 0 a 31)\n\nMo\u017cna r\u00f3wnie\u017c programowa\u0107 dowolne znaki lub symbole, co stwarza wi\u0119cej mo\u017cliwo\u015bci i elastyczno\u015bci w tworzeniu tekstu na wy\u015bwietlaczu."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie": "Zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie mo\u017cna rozwi\u0105za\u0107 korzystaj\u0105c z r\u00f3wnania kinematyki prostoliniowej oraz r\u00f3wnania kinematyki obrotowej.\n\nR\u00f3wnanie kinematyki prostoliniowej opisuje ruch punktu na prostej linii i zapisuje si\u0119 w postaci:\n\ns = vt\n\ngdzie:\n- s to droga przebyta przez punkt\n- v to pr\u0119dko\u015b\u0107 punktu\n- t to czas ruchu punktu\n\nR\u00f3wnanie kinematyki obrotowej opisuje ruch obrotowy bry\u0142y sztywnej wok\u00f3\u0142 osi obrotowej i zapisuje si\u0119 w postaci:\n\n\u03b8 = \u03c9t\n\ngdzie:\n- \u03b8 to k\u0105t obrotu bry\u0142y sztywnej\n- \u03c9 to pr\u0119dko\u015b\u0107 k\u0105towa bry\u0142y sztywnej\n- t to czas ruchu bry\u0142y sztywnej\n\nDla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie, r\u00f3wnanie kinematyki obrotowej mo\u017cna zapisa\u0107 jako:\n\n\u03b81 = \u03c91t\n\ngdzie:\n- \u03b81 to k\u0105t obrotu \u0142\u0105cza obrotowego\n- \u03c91 to pr\u0119dko\u015b\u0107 k\u0105towa \u0142\u0105cza obrotowego\n- t to czas ruchu \u0142\u0105cza obrotowego\n\nAby obliczy\u0107 pr\u0119dko\u015b\u0107 k\u0105tow\u0105 \u0142\u0105cza obrotowego, mo\u017cna skorzysta\u0107 ze wzoru:\n\n\u03c91 = \u0394\u03b81/\u0394t\n\ngdzie:\n- \u0394\u03b81 to zmiana k\u0105ta obrotu \u0142\u0105cza obrotowego\n- \u0394t to czas potrzebny na zmian\u0119 k\u0105ta obrotu\n\nDla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie, pr\u0119dko\u015b\u0107 k\u0105towa \u0142\u0105cza obrotowego mo\u017cna obliczy\u0107 jako:\n\n\u03c91 = (\u03b81 - \u03b80)/(t1 - t0)\n\ngdzie:\n- \u03b80 to pocz\u0105tkowy k\u0105t obrotu \u0142\u0105cza obrotowego\n- t0 to pocz\u0105tkowy czas ruchu \u0142\u0105cza obrotowego\n- \u03b81 to ko\u0144cowy k\u0105t obrotu \u0142\u0105cza obrotowego\n- t1 to ko\u0144cowy czas ruchu \u0142\u0105cza obrotowego\n\nOstatecznie, drog\u0119 przebyt\u0105 przez koniec ramienia manipulatora mo\u017cna obliczy\u0107 korzystaj\u0105c z r\u00f3wnania kinematyki prostoliniowej:\n\ns = r\u03b81\n\ngdzie:\n- r to d\u0142ugo\u015b\u0107 \u0142\u0105cza obrotowego.\n\nPodsumowuj\u0105c, zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie mo\u017cna rozwi\u0105za\u0107 korzystaj\u0105c z r\u00f3wnania kinematyki prostoliniowej oraz r\u00f3wnania kinematyki obrotowej. Oblicza si\u0119 pr\u0119dko\u015b\u0107 k\u0105tow\u0105 \u0142\u0105cza obrotowego oraz drog\u0119 przebyt\u0105 przez koniec ramienia manipulatora."
      }
    ],
    "#n": 33
  },
  "## Plik. 34": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz elementy pami\u0119ci programu mikrokontrolera PIC16f877A.": "Mikrokontroler PIC16f877A posiada nast\u0119puj\u0105ce elementy pami\u0119ci:\n\n1. Pami\u0119\u0107 programu - sk\u0142ada si\u0119 z 14-bitowych s\u0142\u00f3w programowych, kt\u00f3re s\u0105 przechowywane w pami\u0119ci Flash o pojemno\u015bci 14KB. W tej pami\u0119ci przechowywany jest kod programu, kt\u00f3ry steruje dzia\u0142aniem mikrokontrolera.\n\n2. Pami\u0119\u0107 danych RAM - sk\u0142ada si\u0119 z 368 bajt\u00f3w pami\u0119ci, kt\u00f3re s\u0105 podzielone na obszary og\u00f3lnego przeznaczenia, stosu i rejestry specjalne. Pami\u0119\u0107 ta s\u0142u\u017cy do przechowywania zmiennych, flag i innych danych, kt\u00f3re s\u0105 potrzebne do wykonywania programu.\n\n3. Rejestry specjalne - mikrokontroler posiada 21 jednobajtowych rejestr\u00f3w, kt\u00f3rych warto\u015bci s\u0105 wykorzystywane do zarz\u0105dzania systemem mikrokontrolera. Rejestry te s\u0105 dost\u0119pne bezpo\u015brednio dla programisty i s\u0142u\u017c\u0105 do m.in. ustawiania trybu pracy, ustawiania wej\u015b\u0107/wyj\u015b\u0107, konfiguracji przetwornik\u00f3w ADC i PWM.\n\n4. Pami\u0119\u0107 EEPROM - mikrokontroler posiada 256 bajt\u00f3w pami\u0119ci EEPROM, kt\u00f3re s\u0142u\u017c\u0105 do trwa\u0142ego przechowywania danych, np. ustawie\u0144 systemu, wynik\u00f3w pomiar\u00f3w itp. Pami\u0119\u0107 EEPROM jest zastosowana do przechowywania danych na d\u0142u\u017cszy okres czasu, nawet po od\u0142\u0105czeniu zasilania.\n\n5. Pami\u0119\u0107 programu BOOTLOADER - mikrokontroler posiada specjalny obszar pami\u0119ci Flash o pojemno\u015bci 2KB, kt\u00f3ry jest wykorzystywany do \u0142adowania program\u00f3w przez komunikacj\u0119 szeregow\u0105 UART, np. z u\u017cyciem modu\u0142u Bluetooth lub innego interfejsu komunikacyjnego.\n \nWszystkie te elementy pami\u0119ci s\u0105 istotne dla dzia\u0142ania mikrokontrolera i musz\u0105 by\u0107 odpowiednio zaplanowane i zarz\u0105dzane przez programist\u0119. Dzi\u0119ki wysokiej pojemno\u015bci pami\u0119ci oraz mo\u017cliwo\u015bci tworzenia funkcjonalno\u015bci bootloadera programista ma du\u017ce mo\u017cliwo\u015bci implementacji r\u00f3\u017cnych funkcjonalno\u015bci."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy (ADC) przekszta\u0142ca sygna\u0142 analogowy na cyfrowy. Sygna\u0142 analogowy jest sygna\u0142em ci\u0105g\u0142ym, a sygna\u0142 cyfrowy jest reprezentowany jako ci\u0105g zer i jedynek. ADC sk\u0142ada si\u0119 z dw\u00f3ch g\u0142\u00f3wnych blok\u00f3w: samplera i kwantyzatora.\n\nSampler pobiera pr\u00f3bk\u0119 sygna\u0142u analogowego co okre\u015blon\u0105 jednostk\u0119 czasu. Cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania jest okre\u015blona przez instrukcj\u0119 programu. Im wy\u017csza cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, tym dok\u0142adniejszy sygna\u0142 cyfrowy.\n\nKwantyzator przekszta\u0142ca sygna\u0142 analogowy na sygna\u0142 cyfrowy. Pomiar jest tutaj dokonywany poprzez przydzielenie warto\u015bci cyfrowej do danego sygna\u0142u. Ten proces nazywa si\u0119 kwantyzacj\u0105 (okre\u015blanie liczby bit\u00f3w u\u017cywanych do przechowywania warto\u015bci sygna\u0142u cyfrowego).\n\nAby korzysta\u0107 z konwertera analogowo-cyfrowego, niezb\u0119dne jest wykonanie kilku instrukcji w kodzie programu. W pierwszej kolejno\u015bci nale\u017cy ustawi\u0107 w\u0142a\u015bciwy tryb konwersji (np. single-ended lub r\u00f3\u017cnicowa). Nast\u0119pnie nale\u017cy ustawi\u0107 odpowiednie parametry, takie jak cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, rozdzielczo\u015b\u0107, zakres wej\u015bciowy i wzmocnienie. W ko\u0144cu nale\u017cy rozpocz\u0105\u0107 konwersj\u0119 i odczyta\u0107 wynik."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na": "podstawie obrotowej.\n\nZadanie: Dany jest manipulator z\u0142o\u017cony z jednego \u0142\u0105cza pryzmatycznego zamontowanego na podstawie obrotowej. D\u0142ugo\u015b\u0107 \u0142\u0105cza wynosi 0,5 m, a k\u0105t obrotu podstawy wynosi 30 stopni. Oblicz po\u0142o\u017cenie ko\u0144ca manipulatora i pr\u0119dko\u015b\u0107 ko\u0144ca manipulatora.\n\nRozwi\u0105zanie: \n\n1. Wyznaczamy po\u0142o\u017cenie ko\u0144ca manipulatora: \n\nPrzyjmujemy, \u017ce baza manipulatora jest umieszczona w punkcie (0, 0). Po ustawieniu podstawy pod k\u0105tem 30 stopni, jej po\u0142o\u017cenie wynosi (0, 0.5). Zastosujemy teraz proste zale\u017cno\u015bci geometryczne: \n\nx = d*cos(theta) \ny = d*sin(theta) \n\ngdzie: \n- x, y - po\u0142o\u017cenie ko\u0144ca manipulatora \n- d - d\u0142ugo\u015b\u0107 \u0142\u0105cza \n- theta - k\u0105t obrotu podstawy \n\nPodstawiaj\u0105c warto\u015bci: \n\nx = 0.5*cos(30) = 0.433 \ny = 0.5*sin(30) = 0.25 \n\nWynik: po\u0142o\u017cenie ko\u0144ca manipulatora wynosi (0.433, 0.25).\n\n2. Wyznaczamy pr\u0119dko\u015b\u0107 ko\u0144ca manipulatora: \n\nPr\u0119dko\u015b\u0107 ko\u0144ca manipulatora wynika z ruchu obrotowego podstawy. Mo\u017cemy j\u0105 wyznaczy\u0107 jako iloczyn k\u0105towej pr\u0119dko\u015bci podstawy i odleg\u0142o\u015bci od osi obrotu (czyli od punktu (0, 0)): \n\nv = w*d \n\ngdzie: \n- v - pr\u0119dko\u015b\u0107 ko\u0144ca manipulatora \n- w - k\u0105towa pr\u0119dko\u015b\u0107 podstawy \n- d - odleg\u0142o\u015b\u0107 od osi obrotu \n\nWarto\u015b\u0107 odleg\u0142o\u015bci od osi obrotu wynosi 0.5 m (po\u0142owa d\u0142ugo\u015bci \u0142\u0105cza). K\u0105towa pr\u0119dko\u015b\u0107 podstawy mo\u017cemy wyznaczy\u0107 jako zmian\u0119 k\u0105ta w jednostce czasu: \n\nw = delta(theta)/delta(t) \n\nNie podano jednak czasu, wi\u0119c za\u0142o\u017cymy, \u017ce k\u0105t podstawy zmienia si\u0119 o 30 stopni w ci\u0105gu jednej sekundy. Wtedy: \n\nw = 30/360 * 2*pi = 0.5236 rad/s \n\nPodstawiaj\u0105c warto\u015bci: \n\nv = 0.5236 * 0.5 = 0.262 m/s \n\nWynik: pr\u0119dko\u015b\u0107 ko\u0144ca manipulatora wynosi 0.262 m/s."
      }
    ],
    "#n": 34
  },
  "## Plik. 35": {
    "q&a": [
      {
        "Zad. 1 Przedstaw i opisz podstawowe elementy pami\u0119ci mikrokontrolera PIC16f877A.": "Podstawowe elementy pami\u0119ci mikrokontrolera PIC16f877A to:\n\n1. Program Memory (Pami\u0119\u0107 programu): Jest to pami\u0119\u0107 nieulotna, w kt\u00f3rej przechowywany jest kod programu. PIC16f877A ma 14-bitow\u0105 przestrze\u0144 adresow\u0105 programu, co oznacza, \u017ce mo\u017cna z niej korzysta\u0107 z 8192 r\u00f3\u017cnych adres\u00f3w. Pami\u0119\u0107 programu mo\u017ce zawiera\u0107 zar\u00f3wno program u\u017cytkownika, jak i firmware urz\u0105dzenia.\n\n2. Data Memory (Pami\u0119\u0107 danych): Jest to pami\u0119\u0107 ulotna, w kt\u00f3rej przechowywane s\u0105 dane, zmienne i rejestry. PIC16f877A ma 8-bitow\u0105 przestrze\u0144 adresow\u0105 danych, co oznacza, \u017ce mo\u017cna z niej korzysta\u0107 z 256 r\u00f3\u017cnych adres\u00f3w. Pami\u0119\u0107 danych dzieli si\u0119 na dwie cz\u0119\u015bci:\n\n- Ram Memory (Pami\u0119\u0107 RAM): Jest to pami\u0119\u0107, kt\u00f3r\u0105 mikrokontroler mo\u017ce odczytywa\u0107 i zapisywa\u0107 dane w czasie rzeczywistym. Jest to szybka pami\u0119\u0107, ale ulotna i wymaga zasilania, aby przechowywa\u0107 dane.\n- EEPROM Memory (Pami\u0119\u0107 EEPROM): Jest to pami\u0119\u0107 nieulotna, w kt\u00f3rej przechowywane s\u0105 dane d\u0142ugotrwa\u0142e, takie jak informacje konfiguracyjne, has\u0142a, numery seryjne itp. Pami\u0119\u0107 EEPROM jest wolniejsza od RAM, ale jej dane pozostaj\u0105 zachowane nawet po wy\u0142\u0105czeniu zasilania.\n\n3. Special Function Registers (SFRs): S\u0105 to rejestry, kt\u00f3re pe\u0142ni\u0105 specjalne funkcje w mikrokontrolerze. S\u0105 to rejestry programowalne i s\u0142u\u017c\u0105 do sterowania r\u00f3\u017cnymi funkcjami urz\u0105dzenia, takimi jak przerwania, timery, interfejsy komunikacyjne itp.\n\n4. Stack Memory (Pami\u0119\u0107 stosu): Jest to obszar w pami\u0119ci danych, kt\u00f3ry s\u0142u\u017cy do przechowywania informacji o wykonywanych funkcjach i procedurach. W momencie wywo\u0142ania funkcji, adres powrotu i zmienne s\u0105 zapisywane na stosie, aby p\u00f3\u017aniej mo\u017cna by\u0142o odtworzy\u0107 stan przed wywo\u0142aniem funkcji."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "impedancja obci\u0105\u017cenia.\n\n<center><img src=\"https://images.ctfassets.net/al7g91w3yd3h/6Q1WbkvYH5waFwztXtNWng/249b1a578f905d307b2c9a29de6974ba/circuit.png\" alt=\"uk\u0142ad\"></center>\n\nAby obliczy\u0107 nat\u0119\u017cenie pr\u0105du przechodz\u0105cego przez obw\u00f3d, nale\u017cy najpierw obliczy\u0107 ca\u0142kowit\u0105 impedancj\u0119 uk\u0142adu:\n\nZ = R1 + Rs\n\nZ = 50\u2126 + 300\u2126\n\nZ = 350\u2126\n\nNast\u0119pnie nale\u017cy obliczy\u0107 nat\u0119\u017cenie pr\u0105du stosuj\u0105c prawo Ohma:\n\nI = V / Z\n\ngdzie V to napi\u0119cie zasilania. Za\u0142\u00f3\u017cmy, \u017ce napi\u0119cie zasilania wynosi 12V.\n\nI = 12V / 350\u2126\n\nI = 0.034A = 34mA\n\nOdpowied\u017a: Nat\u0119\u017cenie pr\u0105du przechodz\u0105cego przez obw\u00f3d wynosi 34mA."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105-": "czonego z chwytakiem. \n\nW manipulatorze z\u0142o\u017conym z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105czonego z chwytakiem, parametry DH wygl\u0105daj\u0105 nast\u0119puj\u0105co:\n\n1. Theta (k\u0105t obrotu): K\u0105t obrotu \u0142\u0105cza obrotowego wzgl\u0119dem osi Z bazowego uk\u0142adu wsp\u00f3\u0142rz\u0119dnych.\n\n2. d (odleg\u0142o\u015b\u0107): Odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 Z bazowego uk\u0142adu wsp\u00f3\u0142rz\u0119dnych, a osi\u0105 obrotu \u0142\u0105cza obrotowego.\n\n3. a (d\u0142ugo\u015b\u0107): D\u0142ugo\u015b\u0107 \u0142\u0105cza obrotowego.\n\n4. Alpha (k\u0105t obrotu): K\u0105t obrotu \u0142\u0105cza obrotowego wzgl\u0119dem osi X bazowego uk\u0142adu wsp\u00f3\u0142rz\u0119dnych.\n\nZnaj\u0105c te parametry, mo\u017cna okre\u015bli\u0107 macierze transformacji DH dla ka\u017cdego ogniwa manipulatora i obliczy\u0107 pozycj\u0119 i orientacj\u0119 ko\u0144c\u00f3wki."
      }
    ],
    "#n": 35
  },
  "## Plik. 36": {
    "q&a": [
      {
        "Zad. 1 Opisz spos\u00f3b dzia\u0142ania stosu i instrukcje wykorzystywane do jego obs\u0142ugi w mikrokontrolerach klasy PIC18fxx2 i": "Stos to struktura danych LIFO (Last-In-First-Out), kt\u00f3ra pozwala na przechowywanie danych w spos\u00f3b uporz\u0105dkowany. W mikrokontrolerach klasy PIC18fxx2 stos jest obs\u0142ugiwany za pomoc\u0105 rejestr\u00f3w STKPTR oraz STKPTRH, kt\u00f3re przechowuj\u0105 informacje o aktualnym stanie stosu.\n\nAby doda\u0107 dane na stos, nale\u017cy u\u017cy\u0107 instrukcji PUSH lub LCALL, kt\u00f3re umieszczaj\u0105 warto\u015bci na szczycie stosu. Natomiast, aby pobra\u0107 dane ze stosu, stosujemy instrukcj\u0119 POP lub RETLW, kt\u00f3ra pobiera warto\u015b\u0107 ze szczycie stosu i usuwa j\u0105 z kolejki.\n\nDo obs\u0142ugi stosu w mikrokontrolerach klasy PIC18fxx2 wykorzystuje si\u0119 r\u00f3wnie\u017c specjalne instrukcje, takie jak ADDWFC, ADDFSR, SUBWFB, kt\u00f3re pozwalaj\u0105 na manipulowanie warto\u015bciami bezpo\u015brednio na stosie.\n\nPodsumowuj\u0105c, stos w mikrokontrolerach klasy PIC18fxx2 to wa\u017cny element struktury danych, kt\u00f3rej obs\u0142uga odbywa si\u0119 za pomoc\u0105 odpowiednich instrukcji i rejestr\u00f3w. Dzi\u0119ki temu mo\u017cliwe jest przechowywanie i pobieranie danych w spos\u00f3b uporz\u0105dkowany i szybki."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwoma fazami aktywnymi.\n\nSilnik krokowy to rodzaj silnika elektrycznego, kt\u00f3ry obraca si\u0119 zgodnie z impulsami elektrycznymi. Silnik krokowy wykonuje ruchy obrotowe dzi\u0119ki zmiennym polom magnetycznym w jego wn\u0119trzu.\n\nTryb z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105\n\nW trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, tylko jedna z faz silnika krokowego jest aktywna. Zasilanie jednej cewki powoduje obr\u00f3t silnika krokowego o jeden pe\u0142ny krok. Nast\u0119pnie, gdy zasilana zostaje druga cewka, a pierwsza si\u0119 wy\u0142\u0105cza, silnik krokowy obraca si\u0119 o kolejny pe\u0142ny krok. W ten spos\u00f3b silnik krokowy kr\u0119ci si\u0119 z pe\u0142nymi krokami, co oznacza, \u017ce ka\u017cdy krok stanowi okre\u015blon\u0105, dok\u0142adn\u0105 ilo\u015b\u0107 obrot\u00f3w.\n\nTryb z pe\u0142nym krokiem i dwoma fazami aktywnymi\n\nW trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi, dwie fazy silnika krokowego s\u0105 aktywne jednocze\u015bnie. Ta metoda pozwala na jeszcze bardziej precyzyjne sterowanie ruchem silnika, co sprawia, \u017ce jest to najlepsza metoda do zastosowa\u0144 wymagaj\u0105cych bardziej p\u0142ynnego i precyzyjnego ruchu. W spos\u00f3b podobny do trybu z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, silnik obraca si\u0119 z pe\u0142nymi krokami, ale ruch jest jeszcze bardziej dok\u0142adny, poniewa\u017c dwa pola magnetyczne s\u0105 aktywne jednocze\u015bnie. Krok silnika krokowego wynosi wtedy po\u0142ow\u0119 kroku w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105 i pozostaje dok\u0142adny i precyzyjny."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na bazie i": "zako\u0144czonego ko\u0144c\u00f3wk\u0105 chwytaj\u0105c\u0105 za pomoc\u0105 jednego przegubu obrotowego.\n\nAby wyznaczy\u0107 parametry DH dla takiego manipulatora, nale\u017cy przej\u015b\u0107 przez poni\u017csze kroki:\n\nKrok 1: Zdefiniuj uk\u0142ad wsp\u00f3\u0142rz\u0119dnych\n\nZdefiniujmy uk\u0142ad wsp\u00f3\u0142rz\u0119dnych manipulatora. Jako punkt odniesienia, mo\u017cemy wybra\u0107 \u015brodek bazy. Nast\u0119pnie, aby zdefiniowa\u0107 kierunek osi Z\u2081, nale\u017cy wybra\u0107 kierunek, w kt\u00f3rym znajduje si\u0119 obrotowa o\u015b przegubu, a jako os X\u2081 mo\u017cemy wybra\u0107 os pionow\u0105 skierowan\u0105 w d\u00f3\u0142. Ostatnio, jako os Y\u2081, mo\u017cemy wybra\u0107 os r\u00f3wnoleg\u0142\u0105 do p\u0142aszczyzny roboczej manipulatora i skierowan\u0105 w kierunku przeciwnym do przeciwnym do ruchu wskaz\u00f3wek zegara.\n\nKrok 2: Zdefiniuj po\u0142o\u017cenia przegub\u00f3w\n\nZa\u0142\u00f3\u017cmy, \u017ce przegub obrotowy jest umieszczony na ko\u0144cu \u0142\u0105cza pryzmatycznego i s\u0142u\u017cy jako po\u0142\u0105czenie z ko\u0144c\u00f3wk\u0105 chwytaj\u0105c\u0105. Po\u0142o\u017cenie przegubu okre\u015bli si\u0119 jako punkt, w kt\u00f3rym ko\u0144czy si\u0119 \u0142\u0105cze pryzmatyczne. Dla tego manipulatora mo\u017cna przyj\u0105\u0107, \u017ce przegub obrotowy jest jedynym przegubem, wi\u0119c nie ma potrzeby definiowania po\u0142o\u017cenia innych przegub\u00f3w.\n\nKrok 3: Zdefiniuj wektor osi przegubu\n\nO\u015b przegubu obrotowego odpowiada osi Z, kt\u00f3r\u0105 ju\u017c zdefiniowali\u015bmy jako os Z\u2081. Nie ma potrzeby zdefiniowania innych wektor\u00f3w osi, poniewa\u017c manipulator sk\u0142ada si\u0119 tylko z jednego przegubu.\n\nKrok 4: Okre\u015bl k\u0105t obrotu przegubu\n\nK\u0105t obrotu przegubu mo\u017cna okre\u015bli\u0107, wykorzystuj\u0105c ko\u0144c\u00f3wk\u0119 chwytaj\u0105c\u0105. Dla prostoty mo\u017cna za\u0142o\u017cy\u0107, \u017ce po\u0142o\u017cenie ko\u0144c\u00f3wki chwytaj\u0105cej jest okre\u015blone przez warto\u015bci k\u0105towe wok\u00f3\u0142 osi X, Y i Z. W przypadku tego manipulatora, b\u0119dzie to tylko k\u0105t obrotu wok\u00f3\u0142 osi Z. Aby zdefiniowa\u0107 k\u0105t obrotu, mo\u017cna przyj\u0105\u0107, \u017ce przyjmujemy jako pocz\u0105tek k\u0105ta pozycj\u0119 pocz\u0105tkow\u0105, a nast\u0119pnie zmieniamy k\u0105t odpowiednio do po\u0142o\u017cenia ko\u0144c\u00f3wki chwytaj\u0105cej.\n\nKrok 5: Wyznacz parametry DH\n\nMaj\u0105c zdefiniowane wektory osi, po\u0142o\u017cenie przegub\u00f3w i k\u0105ty obrotu, mo\u017cemy teraz wyznaczy\u0107 parametry DH. W tym wypadku, parametry DH wynosz\u0105:\n\n- a\u2081 = 0 (odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 Z\u2081 a Z)\n- \u03b1\u2081 = 0 (k\u0105t mi\u0119dzy osi\u0105 Z\u2081 a Z)\n- d\u2081 = 0 (odleg\u0142o\u015b\u0107 mi\u0119dzy osiami X\u2081 a X)\n- \u03b8\u2081 = k\u0105t obrotu przegubu obrotowego\n\nOstatecznie, macierz transformacji jednorodnej dla tego manipulatora wygl\u0105da nast\u0119puj\u0105co:\n\ncos \u03b8\u2081 -sin \u03b8\u2081 0 0\nsin \u03b8\u2081 cos \u03b8\u2081 0 0\n0 0 1 0\n0 0 0 1"
      }
    ],
    "#n": 36
  },
  "## Plik. 37": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij znaczenie \ufb02ag kon\ufb01guracji w mikrokontrolerze PIC16f877A": "Flagi konfiguracji w mikrokontrolerze PIC16f877A to specjalne bity ustawie\u0144, kt\u00f3re pozwalaj\u0105 na programowanie podstawowych funkcji mikrokontrolera. S\u0105 to bity, kt\u00f3re odpowiadaj\u0105 za tryb pracy mikrokontrolera, rodzaj zegara, ustawienia pin\u00f3w, ustawienia przerwa\u0144, itp. Flagi konfiguracji umo\u017cliwiaj\u0105 ustawienie parametr\u00f3w mikrokontrolera, co jest konieczne dla ka\u017cdej aplikacji, kt\u00f3ra ma by\u0107 wykonana na tym mikrokontrolerze. Warto zauwa\u017cy\u0107, \u017ce flagi konfiguracji s\u0105 bardzo wa\u017cne w mikrokontrolerach, poniewa\u017c ustawienie niepoprawnego trybu pracy, zegara itp. mo\u017ce prowadzi\u0107 do powa\u017cnych problem\u00f3w z dzia\u0142aniem ca\u0142ego systemu."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze P-N to po\u0142\u0105czenie p\u00f3\u0142przewodnika typu P (domieszkowany pierwiastkami trzeciej grupy, takimi jak bor) z p\u00f3\u0142przewodnikiem typu N (domieszkowany pierwiastkami pi\u0105tej grupy, takimi jak fosfor). Zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N obejmuj\u0105:\n\n1. Zjawisko Dyfuzji: podczas dzie\u0144 zmiany koncentracji wielko\u015b\u0107\n\n2. Zjawisko Deplekcji: W z\u0142\u0105czu P-N jest miejsce, w kt\u00f3rym pojawi\u0142 si\u0119 polaryzacja. \n\n3. Efekt Halloa: Zjawisko to polega na powstaniu napi\u0119cia elektrycznego wzd\u0142u\u017c z\u0142\u0105cza P-N, gdy pr\u0105d p\u0142ynie przez z\u0142\u0105cze pod wp\u0142ywem pola magnetycznego.\n\n4. Zjawisko Rekombinacji: W z\u0142\u0105czu P-N elektrony z domieszkowanego N i brakuj\u0105ce wprowadzone w P rejonie dziury rekombinuj\u0105 ze sob\u0105. \n\n5. Zjawisko Bariera Energii: Na granicy z\u0142\u0105cza P-N pojawi\u0142a si\u0119 bariera potencja\u0142u spowodowana r\u00f3\u017cnic\u0105 koncentracji wewn\u0105trz.\n\nWskutek tych zjawisk w z\u0142\u0105czu P-N nast\u0119puje przep\u0142yw pr\u0105du i tworzenie warstwy zaporowej, kt\u00f3ra pozwala na kontrolowanie przep\u0142ywu pr\u0105du w uk\u0142adzie elektronicznym."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "dP/dt = k*(P-Po)\n\ngdzie:\n\nP - warto\u015b\u0107 zmiennej, kt\u00f3r\u0105 mierzy czujnik\n\nPo - warto\u015b\u0107 docelowa (poziom zale\u017cny od zastosowania czujnika)\n\nk - sta\u0142a proporcjonalno\u015bci\n\nR\u00f3wnanie to opisuje zachowanie czujnika w czasie - dynamik\u0119 jego dzia\u0142ania. Zmiana warto\u015bci zmierzonej przez czujnik przez czas jest opisana lewostronn\u0105 pochodn\u0105 tej warto\u015bci wzgl\u0119dem czasu. Sta\u0142y cz\u0142on k*(P-Po) okre\u015bla, jaki jest aktualny wp\u0142yw odchylenia warto\u015bci zmierzonej od warto\u015bci docelowej na zmian\u0119 P w czasie. Im wi\u0119ksze jest to odchylenie, tym wi\u0119ksza jest si\u0142a, kt\u00f3ra zmienia P w kierunku Po. Sta\u0142\u0105 k nale\u017cy dobra\u0107 odpowiednio do zastosowania czujnika i wymaga\u0144 dotycz\u0105cych jego dok\u0142adno\u015bci i responsywno\u015bci."
      }
    ],
    "#n": 37
  },
  "## Plik. 38": {
    "q&a": [
      {
        "Zad. 1 Czym jest histereza w uk\u0142adach wej\u015bciowo-wyj\u015bciowych.": "Histereza w uk\u0142adach wej\u015bciowo-wyj\u015bciowych oznacza zjawisko, w kt\u00f3rym warto\u015b\u0107 wyj\u015bcia zale\u017cy nie tylko od warto\u015bci wej\u015bcia, ale tak\u017ce od historii zmian warto\u015bci wej\u015bcia. Innymi s\u0142owy, warto\u015b\u0107 wyj\u015bcia zale\u017cy od tego, czy zmiana warto\u015bci wej\u015bcia nast\u0105pi\u0142a wzwy\u017c czy w d\u00f3\u0142 oraz od tego, jak dawno ta zmiana nast\u0105pi\u0142a. Przyk\u0142adami uk\u0142ad\u00f3w, w kt\u00f3rych wyst\u0119puje histereza, s\u0105 przeka\u017aniki elektromagnetyczne, narz\u0119dzia pomiarowe i elementy steruj\u0105ce, takie jak regulatory temperatury czy czujniki wibracji. Histereza mo\u017ce wprowadza\u0107 b\u0142\u0119dy w pomiarach i utrudnia\u0107 kontrolowanie wyj\u015bcia uk\u0142adu, co wymaga dostosowania parametr\u00f3w regulator\u00f3w do konkretnych warunk\u00f3w pracy."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 manipulatora SCARA.": "Ruchliwo\u015b\u0107 manipulatora SCARA zale\u017cy od jego konstrukcji oraz liczby stopni swobody. \n\nStandardowy manipulator SCARA ma cztery stopnie swobody, co oznacza, \u017ce mo\u017ce porusza\u0107 si\u0119 w czterech r\u00f3\u017cnych kierunkach. Konkretnie, mo\u017ce wykonywa\u0107 ruchy liniowe wzd\u0142u\u017c dw\u00f3ch osi poziomych (x i y) oraz ruchy obrotowe wok\u00f3\u0142 dw\u00f3ch osi pionowych (z i k\u0105towa rotacja nad z). \n\nRuchliwo\u015b\u0107 manipulatora SCARA mo\u017cna obliczy\u0107 za pomoc\u0105 formu\u0142y:\n\nR = 6 - n - m\n\ngdzie:\n- R - ruchliwo\u015b\u0107 manipulatora, czyli liczba niezale\u017cnych ruch\u00f3w, jakie mo\u017ce wykonywa\u0107,\n- n - liczba stopni swobody (degree of freedom, DOF),\n- m - liczba zale\u017cno\u015bci kinematycznych.\n\nW przypadku standardowego manipulatora SCARA, mamy n = 4, poniewa\u017c ma on cztery stopnie swobody. Jednak z powodu konstrukcji, kiedy rami\u0119 manipulatora jest ca\u0142kowicie rozprostowane, jego ko\u0144c\u00f3wka jest ledwo poruszalna. Dlatego manipulator SCARA ma jedn\u0105 zale\u017cno\u015b\u0107 kinematyczn\u0105 (m = 1), kt\u00f3ra ogranicza jego ruchliwo\u015b\u0107.\n\nSt\u0105d wynika, \u017ce ruchliwo\u015b\u0107 manipulatora SCARA wynosi:\n\nR = 6 - 4 - 1 = 1\n\nOznacza to, \u017ce manipulator SCARA mo\u017ce wykonywa\u0107 tylko jeden niezale\u017cny ruch w dowolnym punkcie przestrzeni roboczej."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym, kt\u00f3re opisuje zale\u017cno\u015b\u0107 mi\u0119dzy sygna\u0142em wyj\u015bciowym czujnika a warto\u015bci\u0105 mierzonej wielko\u015bci. R\u00f3wnanie to mo\u017cna zapisa\u0107 w postaci:\n\ny(t) = f(x(t))\n\ngdzie:\n- y oznacza sygna\u0142 wyj\u015bciowy czujnika,\n- x oznacza warto\u015b\u0107 mierzonej wielko\u015bci,\n- t oznacza czas,\n- f jest funkcj\u0105 opisuj\u0105c\u0105 charakterystyk\u0119 czujnika.\n\nPrzyk\u0142adowo, je\u015bli czujnik jest termometryczny, to sygna\u0142 wyj\u015bciowy b\u0119dzie zale\u017ca\u0142 od temperatury mierzonej przez ten czujnik. Funkcja f opisuje wtedy charakterystyk\u0119 konkretnego czujnika termometrycznego i pozwala na przeliczenie warto\u015bci temperatury na sygna\u0142 elektryczny, kt\u00f3ry mo\u017ce by\u0107 przetworzony przez urz\u0105dzenia pomiarowe."
      }
    ],
    "#n": 38
  },
  "## Plik. 39": {
    "q&a": [
      {
        "Zad. 1 W jaki spos\u00f3b zjawisko piezoelektryczne jest wykorzystywane do budowy mikrofon\u00f3w.": "Zjawisko piezoelektryczne jest wykorzystywane do budowy mikrofon\u00f3w elektrodynamcznych. Mikrofony te zawieraj\u0105 b\u0142on\u0119 piezoelektryczn\u0105, kt\u00f3ra ulega deformacji w wyniku fali d\u017awi\u0119kowej. Ta deformacja generuje napi\u0119cie elektryczne, kt\u00f3re jest wzmacniane przez uk\u0142ady elektroniczne w mikrofonie i przekszta\u0142cane na sygna\u0142 d\u017awi\u0119kowy. \n\nB\u0142ona piezoelektryczna w mikrofonie sk\u0142ada si\u0119 z kryszta\u0142\u00f3w lub ceramicznego materia\u0142u piezoelektrycznego, kt\u00f3ry jest po\u0142\u0105czony z metalowymi elektrodami. Gdy fala d\u017awi\u0119kowa uderza w b\u0142on\u0119, powoduje jej deformacj\u0119, co zmienia polaryzacj\u0119 kryszta\u0142\u00f3w piezoelektrycznych i generuje napi\u0119cie elektryczne na metalowych elektrodach. \n\nNapi\u0119cie to jest nast\u0119pnie przetwarzane przez uk\u0142ady elektroniczne w mikrofonie, takie jak wzmacniacze sygna\u0142u, filtry i uk\u0142ady redukcji szum\u00f3w. W ko\u0144cu, sygna\u0142 jest sk\u0142adowany w postaci cyfrowej lub analogowej. Mikrofony elektrodynamczne s\u0105 szeroko stosowane w r\u00f3\u017cnych zastosowaniach, takich jak nagrywanie wokalu, instrument\u00f3w muzycznych, emisji g\u0142osu w systemach bezprzewodowych oraz w pomiarach akustycznych i wibracyjnych."
      },
      {
        "Zad. 2 Oblicz, jaka jest ruchliwo\u015b\u0107 (typowego) manipulatora ramieniowego.": "Nie jest mo\u017cliwe jednoznaczne okre\u015blenie ruchliwo\u015bci typowego manipulatora ramieniowego, poniewa\u017c ruchliwo\u015b\u0107 zale\u017cy od wielu czynnik\u00f3w, takich jak liczba stopni swobody, d\u0142ugo\u015b\u0107 ramion, pr\u0119dko\u015b\u0107 i si\u0142a nap\u0119d\u00f3w oraz styl pracy manipulatora. Jednak\u017ce, typowe manipulatory ramieniowe maj\u0105 zwykle od 4 do 6 stopni swobody, co oznacza, \u017ce mog\u0105 wykonywa\u0107 ruchy w 4-6 kierunkach lub p\u0142aszczyznach. Ostatecznie, ruchliwo\u015b\u0107 manipulatora ramieniowego zale\u017cy od konkretnej konstrukcji urz\u0105dzenia i jej przeznaczenia."
      },
      {
        "Zad. 3 Dany jest czujnik opisany r\u00f3wnaniem r\u00f3\u017cniczkowym": "Nie jestem w stanie poda\u0107 r\u00f3wnania r\u00f3\u017cniczkowego opisuj\u0105cego dany czujnik bez dodatkowych informacji na temat jego charakterystyki i dzia\u0142ania. Prosz\u0119 o podanie bardziej szczeg\u00f3\u0142owego opisu czujnika lub jego nazwy."
      }
    ],
    "#n": 39
  },
  "## Plik. 40": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania termopary i \u0142a\u0144cucha termicznego.": "Termopara to urz\u0105dzenie pomiarowe s\u0142u\u017c\u0105ce do pomiaru temperatury. Sk\u0142ada si\u0119 ona z dw\u00f3ch r\u00f3\u017cnych metalowych przewod\u00f3w po\u0142\u0105czonych ze sob\u0105 w jednym ko\u0144cu, a w drugim ko\u0144cu przetwarzaj\u0105cy sygna\u0142 elektryczny. Kiedy temperatura ko\u0144ca pomiarowego ulega zmianie, to powoduje to produkcj\u0119 r\u00f3\u017cnicy potencja\u0142\u00f3w pomi\u0119dzy metalowymi przewodami. Ta r\u00f3\u017cnica potencja\u0142\u00f3w jest proporcjonalna do r\u00f3\u017cnicy temperatur pomi\u0119dzy ko\u0144cami metalowych przewod\u00f3w, co umo\u017cliwia pomiar temperatury.\n\nLancuch termiczny natomiast to zestaw element\u00f3w po\u0142\u0105czonych ze sob\u0105 termicznie, maj\u0105cych za zadanie przekazywanie ciep\u0142a z jednego punktu na inny. Sk\u0142ada si\u0119 z termopary (odpowiednio skonfigurowanej, tj. w zale\u017cno\u015bci od zastosowania), przewod\u00f3w po\u0142\u0105czeniowych i \u017ar\u00f3d\u0142a ciep\u0142a. Pomiar temperatury w takim systemie mo\u017cna przeprowadzi\u0107 w r\u00f3\u017cnych punktach w zale\u017cno\u015bci od u\u0142o\u017cenia termopary i przewod\u00f3w. Podczas tego procesu zachodz\u0105 r\u00f3\u017cne procesy termodynamiczne, np. przewodzenie, konwekcja czy promieniowanie, kt\u00f3re decyduj\u0105 o przenoszeniu energii cieplnej pomi\u0119dzy poszczeg\u00f3lnymi elementami \u0142a\u0144cucha termicznego."
      },
      {
        "Zad. 2 Wykonaj obr\u00f3t punktu [1,1,1]o30\u25e6dooko\u0142a wektora [0.5,0.4,0.3]. Zamie\u015b\u0107 odpowiednie obliczenia.": "Aby wykona\u0107 obr\u00f3t punktu o 30\u00b0 wok\u00f3\u0142 wektora, nale\u017cy najpierw obliczy\u0107 macierz obrotu dla tego k\u0105ta i wektora, a nast\u0119pnie pomno\u017cy\u0107 j\u0105 przez wsp\u00f3\u0142rz\u0119dne punktu.\n\nMacierz obrotu dla k\u0105ta 30\u00b0 i wektora [0.5,0.4,0.3] mo\u017cna obliczy\u0107 wed\u0142ug nast\u0119puj\u0105cego wzoru:\n\ncos(30\u00b0)   + (1 - cos(30\u00b0)) * 0.5^2      + (1 - cos(30\u00b0)) * 0.5 * 0.4  - sin(30\u00b0) * 0.3\n(1 - cos(30\u00b0)) * 0.5 * 0.4  + cos(30\u00b0)       + (1 - cos(30\u00b0)) * 0.4^2      + sin(30\u00b0) * 0.5\n(1 - cos(30\u00b0)) * 0.5 * 0.3  - sin(30\u00b0) * 0.4 + (1 - cos(30\u00b0)) * 0.4 * 0.3  + cos(30\u00b0)\n\ngdzie \"cos(30\u00b0)\" i \"sin(30\u00b0)\" odpowiadaj\u0105 warto\u015bciom cosinus i sinus k\u0105ta 30\u00b0.\n\nPo obliczeniu macierzy mo\u017cemy pomno\u017cy\u0107 j\u0105 przez wektor [1,1,1] w celu uzyskania wsp\u00f3\u0142rz\u0119dnych punktu po obr\u00f3ceniu:\n\ncos(30\u00b0)   + (1 - cos(30\u00b0)) * 0.5^2      + (1 - cos(30\u00b0)) * 0.5 * 0.4  - sin(30\u00b0) * 0.3    |     1\n(1 - cos(30\u00b0)) * 0.5 * 0.4  + cos(30\u00b0)       + (1 - cos(30\u00b0)) * 0.4^2      + sin(30\u00b0) * 0.5    |  *  1\n(1 - cos(30\u00b0)) * 0.5 * 0.3  - sin(30\u00b0) * 0.4 + (1 - cos(30\u00b0)) * 0.4 * 0.3  + cos(30\u00b0)         |     1\n\nPo pomno\u017ceniu otrzymujemy:\n\n[1.1917, 1.0585, 0.8567]\n\nWsp\u00f3\u0142rz\u0119dne punktu po obr\u00f3ceniu wynosz\u0105 [1.1917, 1.0585, 0.8567]."
      },
      {
        "Zad. 3 Wyznacz (przybli\u017con\u0105) liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika, dla kt\u00f3rego zebrano do\u015bwiadczalnie": "dane przedstawione w poni\u017cszej tabeli:\n\n| Wej\u015bcie [V] | Wyj\u015bcie [mA] |\n|------------|--------------|\n| 0          | 0            |\n| 0.5        | 1.2          |\n| 1.0        | 2.5          |\n| 1.5        | 3.8          |\n| 2.0        | 5.0          |\n\nAby wyznaczy\u0107 liniow\u0105 charakterystyk\u0119 wej\u015bciowo-wyj\u015bciow\u0105 czujnika nale\u017cy pos\u0142u\u017cy\u0107 si\u0119 regresj\u0105 liniow\u0105. W przypadku tych danych zastosowanej regresji mo\u017cna dokona\u0107 na przyk\u0142ad za pomoc\u0105 programu Excel. \n\nPo wpisaniu danych do arkusza kalkulacyjnego, nale\u017cy wybra\u0107 opcj\u0119 wykresu i zaznaczy\u0107 lini\u0119 trendu (tutaj regresj\u0119 liniow\u0105). W rezultacie otrzymujemy wykres z prost\u0105, kt\u00f3ra najlepiej odwzorowuje zale\u017cno\u015b\u0107 mi\u0119dzy wej\u015bciem a wyj\u015bciem. \n\nDla tych konkretnych danych, liniowa charakterystyka wej\u015bciowo-wyj\u015bciowa czujnika mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co:\n\ny = 2.5x - 0.5 \n\ngdzie y oznacza wyj\u015bcie [mA], a x wej\u015bcie [V]. \n\nJest to prosty wz\u00f3r funkcji liniowej, kt\u00f3ra w uproszczony spos\u00f3b opisuje zachowanie badanego czujnika. Oczywi\u015bcie, warto pami\u0119ta\u0107, \u017ce w ka\u017cdym przypadku dob\u00f3r najlepszego modelu opisu zale\u017cno\u015bci mi\u0119dzy danymi zale\u017cy od charakteru badanego procesu oraz od jako\u015bci zebranych danych."
      }
    ],
    "#n": 40
  },
  "## Plik. 41": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania kamery CCD.": "Kamera CCD (przetwornik \u0142adunkowy) sk\u0142ada si\u0119 z matrycy mikroskopijnych pikseli, kt\u00f3re rejestruj\u0105 \u015bwiat\u0142o padaj\u0105ce na nie. Piksele s\u0105 na\u0142adowane elektrycznie, a gdy \u015bwiat\u0142o pada na piksel, fotoelektrony s\u0105 wybijane z tej na\u0142adowanej warstwy. \n\nGdy fotoelektrony zostaj\u0105 uwolnione, s\u0105 one przyci\u0105gane przez napi\u0119cie elektryczne i gromadzone na specjalnych pojemnikach nazywanych tak\u017ce \"studniami \u0142adunkowymi\". Kiedy matryca pikseli zostaje o\u015bwietlona, studnie \u0142adunkowe wype\u0142niaj\u0105 si\u0119 r\u00f3\u017cnymi ilo\u015bciami \u0142adunk\u00f3w, reprezentuj\u0105cymi r\u00f3\u017cne poziomy jasno\u015bci piksela.\n\nNast\u0119pnie, po pokryciu ca\u0142ej matrycy, \u0142adunki s\u0105 odczytywane przez uk\u0142ad odczytu, kt\u00f3ry przesy\u0142a te dane do przetwornika analogowo-cyfrowego (ADC). \n\nADC przekszta\u0142ca sygna\u0142 analogowy na cyfrowy, co pozwala na zapisanie danych w postaci pliku numerycznego na pami\u0119ci karty. W ten spos\u00f3b uzyskujemy kolorow\u0105 lub monochromatyczn\u0105 reprezentacj\u0119 obrazu zarejestrowanego przez kamer\u0119 CCD. \n\nWarto zauwa\u017cy\u0107, \u017ce kamera CCD umo\u017cliwia rejestrowanie obrazu tylko w warunkach dobrze o\u015bwietlonych, poniewa\u017c im mniej \u015bwiat\u0142a pada na piksele, tym trudniejsze staje si\u0119 ich odczytanie."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b oprogramowywania wy\u015bwietlacza HD44780. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wy\u015bwietlenia": "Tekstu na wy\u015bwietlaczu HD44780 mo\u017cna programowa\u0107 za pomoc\u0105 mikrokontrolera, takiego jak Arduino lub Raspberry Pi. Aby zacz\u0105\u0107, nale\u017cy pod\u0142\u0105czy\u0107 wy\u015bwietlacz do p\u0142ytki rozwojowej zgodnie z instrukcj\u0105 producenta.\n\nNast\u0119pnie nale\u017cy wysy\u0142a\u0107 instrukcje do wy\u015bwietlacza poprzez po\u0142\u0105czenie danych i sterowania. W przypadku wy\u015bwietlacza HD44780 s\u0105 to 8 lub 4 linie danych oraz 3 linie steruj\u0105ce: RS (Register Select), E (Enable) i R/W (Read/Write).\n\nW celu wy\u015bwietlenia tekstu nale\u017cy przes\u0142a\u0107 kilka instrukcji do wy\u015bwietlacza, w tym:\n\n1. Ustawienie trybu wy\u015bwietlania: 8-bitowy lub 4-bitowy.\n2. W\u0142\u0105czenie wy\u015bwietlacza.\n3. Ustawienie kursora na pocz\u0105tku pierwszej linii.\n4. Wys\u0142anie danych do wy\u015bwietlacza, w tym znak\u00f3w, znak\u00f3w specjalnych i polece\u0144.\n\nPor\u00f3wnanie 4-bitowego i trybu 8-bitowego:\n\nW trybie 8-bitowym ka\u017cdy bajt danych wysy\u0142any jest za pomoc\u0105 o\u015bmiu linii danych, a w trybie 4-bitowym za pomoc\u0105 czterech linii. Tryb 4-bitowy wymaga odczytania i zapisu mniej danych, co mo\u017ce przyspieszy\u0107 komunikacj\u0119 mi\u0119dzy mikrokontrolerem a wy\u015bwietlaczem.\n\nPrzyk\u0142ady instrukcji:\n\n- Ustawienie trybu 4-bitowego:\nRS=0,E=1,D7-D4=0x02,E=0\n\n- W\u0142\u0105czenie wy\u015bwietlacza i kursora:\nRS=0,E=1,D7-D4=0x0E,E=0\n\n- Ustawienie kursora na pocz\u0105tku pierwszej linii:\nRS=0,E=1,D7-D4=0x80,E=0\n\n- Wys\u0142anie tekstu, np. \"Hello World!\":\nRS=1,E=1,D7-D4='H',E=0,E=1,D7-D4='e',E=0,E=1,D7-D4='l',E=0,E=1,D7-D4='l',E=0,E=1,D7-D4='o',E=0,E=1,D7-D4=' ',E=0,E=1,D7-D4='W',E=0,E=1,D7-D4='o',E=0,E=1,D7-D4='r',E=0,E=1,D7-D4='l',E=0,E=1,D7-D4='d',E=0,E=1,D7-D4='!',E=0\n\nWysy\u0142aj\u0105c te instrukcje w odpowiedniej kolejno\u015bci i z odpowiednimi parametrami, mo\u017cna wy\u015bwietli\u0107 dowolny tekst na wy\u015bwietlaczu HD44780."
      }
    ],
    "#n": 41
  },
  "## Plik. 42": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter analogowo-cyfrowy (ADC) s\u0142u\u017cy do przetworzenia sygna\u0142u analogowego (np. napi\u0119cia) na sygna\u0142 cyfrowy. W celu dokonania pomiaru, sygna\u0142 analogowy jest pr\u00f3bkowany, czyli pobierane s\u0105 pr\u00f3bki sygna\u0142u w okre\u015blonych momentach czasowych. Nast\u0119pnie sygna\u0142 ten jest kwantowany, czyli sygna\u0142 analogowy jest zaokr\u0105glany do najbli\u017cszej warto\u015bci z okre\u015blonej skali. W przypadku kwantyzacji r\u00f3wnomiernych, skala jest podzielona na r\u00f3wne przedzia\u0142y o szeroko\u015bci \u0394:\n\nVquant = \u0394 * round (Vinput / \u0394)\n\nGdzie:\nVinput \u2013 warto\u015b\u0107 sygna\u0142u wej\u015bciowego,\n\u0394 \u2013 szeroko\u015b\u0107 przedzia\u0142u kwantyzacji,\nVquant \u2013 warto\u015b\u0107 skwantowana sygna\u0142u.\n\nNast\u0119pnie warto\u015bci skwantowane s\u0105 kodowane w formacie binarnym. Ilo\u015b\u0107 bit\u00f3w wykorzystywanych do kodowania warto\u015bci (rozmiar s\u0142owa) wp\u0142ywa na dok\u0142adno\u015b\u0107 pomiaru. Im wi\u0119kszy rozmiar s\u0142owa, tym wi\u0119ksza dok\u0142adno\u015b\u0107, ale r\u00f3wnie\u017c wi\u0119ksze wymagania dla przetwarzania danych. \n\nKorzystaj\u0105c z konwertera ADC mo\u017cna w prosty spos\u00f3b zbada\u0107 zmiany sygna\u0142u analogowego i przekszta\u0142ci\u0107 je na komputerow\u0105 posta\u0107, co pozwala na ich dalsze przetwarzanie i analiz\u0119."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera analogowo-cyfrowego. Wyja\u015bnij jakie instrukcje s\u0105 niezb\u0119dne do wykonania": "Konwerter analogowo-cyfrowy (ADC) jest urz\u0105dzeniem elektronicznym, kt\u00f3ry przetwarza sygna\u0142 analogowy na sygna\u0142 cyfrowy. Sygna\u0142 analogowy jest w postaci ci\u0105g\u0142ej zmienno\u015bci sygna\u0142u, natomiast sygna\u0142 cyfrowy jest w postaci ci\u0105gu impuls\u00f3w. Konwerter analogowo-cyfrowy sk\u0142ada si\u0119 z kilku blok\u00f3w: wzmacniacza, komparatora, licznika oraz rejestru przesuwnego.\n\nWzmacniacz wzmacnia sygna\u0142 analogowy do odpowiedniego poziomu, aby m\u00f3c go por\u00f3wna\u0107 z ustalon\u0105 warto\u015bci\u0105 progow\u0105 przez komparator. Komparator por\u00f3wnuje sygna\u0142 analogowy z warto\u015bci\u0105 progow\u0105 i generuje impuls cyfrowy o warto\u015bci 0 lub 1. Licznik zlicza pulsacje cyfrowe, a\u017c do momentu, gdy generowany jest impuls wystarczaj\u0105co silny, aby licznik zmieni\u0142 swoj\u0105 warto\u015b\u0107. Ostatecznie, warto\u015b\u0107 zapisana w liczniku jest przesuwana do rejestru przesuwnego, z kt\u00f3rego mo\u017cna j\u0105 odczyta\u0107 w postaci kodu binarnego.\n\nAby wykona\u0107 konwersj\u0119 analogowo-cyfrow\u0105, nale\u017cy ustawi\u0107 warto\u015b\u0107 napi\u0119cia wej\u015bciowego oraz dok\u0142adno\u015b\u0107 konwersji. Nast\u0119pnie nale\u017cy przekaza\u0107 sygna\u0142 wej\u015bciowy do wzmacniacza i ustawi\u0107 warto\u015b\u0107 progow\u0105 w komparatorze. Po wykonaniu konwersji, warto\u015b\u0107 cyfrowa jest przenoszona do rejestru przesuwnego, aby umo\u017cliwi\u0107 jego odczytanie."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie": "Nie zosta\u0142y podane \u017cadne warto\u015bci, wi\u0119c nie mo\u017cna rozwi\u0105za\u0107 tego zadania, ale mo\u017cna przedstawi\u0107 og\u00f3ln\u0105 metod\u0119 rozwi\u0105zania:\n\n1. Okre\u015bl uk\u0142ad wsp\u00f3\u0142rz\u0119dnych, w kt\u00f3rym b\u0119dziesz opisywa\u0142 ruch manipulatora (np. uk\u0142ad kartezja\u0144ski czy biegunowy).\n2. Przyjmij jakie\u015b warto\u015bci dla k\u0105ta obrotu \u0142\u0105cza (np. 30 stopni) oraz pr\u0119dko\u015bci obrotowej \u0142\u0105cza (np. 2 obr./s).\n3. Korzystaj\u0105c z geometrii manipulatora oraz warto\u015bci k\u0105ta obrotu, oblicz po\u0142o\u017cenie ko\u0144ca manipulatora (np. ko\u0144c\u00f3wki narz\u0119dzia) wzgl\u0119dem uk\u0142adu wsp\u00f3\u0142rz\u0119dnych.\n4. Korzystaj\u0105c z kinematyki odwrotnej, oblicz warto\u015bci k\u0105t\u00f3w w stawach pozwalaj\u0105ce na osi\u0105gni\u0119cie po\u017c\u0105danego po\u0142o\u017cenia ko\u0144ca manipulatora.\n5. Przyjmij jakie\u015b warto\u015bci dla przyspieszenia obrotowego \u0142\u0105cza (np. 5 obr./s^2) oraz czasu trwania ruchu (np. 2 s).\n6. Korzystaj\u0105c z r\u00f3wna\u0144 kinematycznych, oblicz warto\u015bci pr\u0119dko\u015bci oraz przyspiesze\u0144 w stawach w trakcie ruchu.\n7. Sprawd\u017a, czy warto\u015bci pr\u0119dko\u015bci i przyspiesze\u0144 s\u0105 zgodne z mo\u017cliwo\u015bciami mechanicznymi manipulatora (np. czy przyspieszenie nie przekracza dopuszczalnych warto\u015bci).\n8. Mo\u017cna przedstawi\u0107 ruch manipulatora w postaci wykres\u00f3w zale\u017cno\u015bci k\u0105ta, pr\u0119dko\u015bci i przyspieszenia od czasu."
      }
    ],
    "#n": 42
  },
  "## Plik. 43": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij spos\u00f3b dzia\u0142ania konwertera cyfrowo-analogowego. Zamie\u015b\u0107 niezb\u0119dne obliczenia.": "Konwerter cyfrowo-analogowy (DAC) to urz\u0105dzenie, kt\u00f3re przetwarza dane cyfrowe na sygna\u0142 analogowy, kt\u00f3ry mo\u017ce by\u0107 wykorzystany do sterowania urz\u0105dzeniami takimi jak g\u0142o\u015bniki, motory, pompy, itp. \n\nSpos\u00f3b dzia\u0142ania konwertera cyfrowo-analogowego polega na przetwarzaniu warto\u015bci cyfrowych na warto\u015bci analogowej napi\u0119cia lub pr\u0105du. Najprostszy rodzaj DAC-a to konwerter typu trybuie\u0144czego, w kt\u00f3rym ka\u017cdy bit sygna\u0142u cyfrowego jest konwertowany na oznaczon\u0105 warto\u015b\u0107 napi\u0119cia lub pr\u0105du. \n\nNa przyk\u0142ad, je\u015bli mamy 8-bitowy sygna\u0142 cyfrowy, kt\u00f3ry ma warto\u015b\u0107 10101101 (w systemie dziesi\u0119tnym 173), ka\u017cdy bit mo\u017ce by\u0107 konwertowany na napi\u0119cie lub pr\u0105d odpowiadaj\u0105cy 1/256 ca\u0142kowitej warto\u015bci wyj\u015bciowej. Ostatecznie, w pe\u0142ni skonwertowany sygna\u0142 wyj\u015bciowy b\u0119dzie r\u00f3wny:\n\nVout = (1/256) * (1*1 + 0*2 + 1*4 + 0*8 + 1*16 + 1*32 + 0*64 + 1*128)\n\nVout = (1/256) * (173)\n\nVout = 0.676 V\n\nWarto\u015b\u0107 napi\u0119cia lub pr\u0105du, kt\u00f3r\u0105 mo\u017cna uzyska\u0107 jako wynik konwersji, mo\u017ce by\u0107 kontrolowana przez u\u017cytkownika poprzez wyb\u00f3r odpowiedniego punktu odniesienia, kt\u00f3ry okre\u015bla zakres warto\u015bci analogowych. Dla przyk\u0142adu, je\u015bli chcemy uzyska\u0107 napi\u0119cie wyj\u015bciowe w zakresie 0-5 V, wtedy ka\u017cdej warto\u015bci analogowej odpowiada 19,53 mV. \n\nKonwerter cyfrowo-analogowy mo\u017ce by\u0107 r\u00f3wnie\u017c stosowany w wielu innych aplikacjach, np. sterowaniu silnikami, pilotowaniu wy\u015bwietlaczy LCD, konstrukcji uk\u0142ad\u00f3w chirurgicznych, wprowadzaniu zmian w sygnale d\u017awi\u0119kowym lub graficznym, itp."
      },
      {
        "Zad. 2 Uk\u0142ad jest przedstawiony jak na rysunku, gdzie R1= 50\u2126 to impedancja uk\u0142adu zasilania, a Rs= 300\u2126 to": "impedancja obci\u0105\u017cenia. \n\n![UK\u0141AD](https://i.imgur.com/SgCOvls.png)\n\nAby obliczy\u0107 pr\u0105d I p\u0142yn\u0105cy przez obci\u0105\u017cenie, musimy najpierw obliczy\u0107 napi\u0119cie V wyj\u015bciowe z uk\u0142adu.\n\nWykorzystuj\u0105c podzia\u0142 napi\u0119cia i zast\u0119puj\u0105c impedancj\u0119 szeregow\u0105 R1 i Rs impedancj\u0105 zast\u0119pcz\u0105, otrzymujemy:\n\nV = Vi * Rs / (R1 + Rs) = 10 * 300 / (50 + 300) = 8 V\n\nNast\u0119pnie, wykorzystuj\u0105c prawo Ohma, mo\u017cemy obliczy\u0107 pr\u0105d p\u0142yn\u0105cy przez obci\u0105\u017cenie:\n\nI = V / Rs = 8 / 300 = 0,0267 A = 26,7 mA\n\nOdpowied\u017a: Pr\u0105d p\u0142yn\u0105cy przez obci\u0105\u017cenie wynosi 26,7 mA."
      },
      {
        "Zad. 3 Rozwi\u0105\u017c proste zadanie kinematyki dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na": "podstawie obrotowej.\n\nNie podano dok\u0142adnego sformu\u0142owania zadania, dlatego poni\u017cej przedstawione zostan\u0105 og\u00f3lne zasady ruchu manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego.\n\nManipulator z\u0142o\u017cony z jednego \u0142\u0105cza pryzmatycznego umieszczony na podstawie obrotowej mo\u017ce osi\u0105gn\u0105\u0107 r\u00f3\u017cne po\u0142o\u017cenia i orientacje w przestrzeni. Aby opisa\u0107 jego ruch, stosuje si\u0119 parametry opisuj\u0105ce po\u0142o\u017cenie i orientacj\u0119 \u0142\u0105cza.\n\nPo\u0142o\u017cenie \u0142\u0105cza mo\u017cna opisa\u0107 za pomoc\u0105 wsp\u00f3\u0142rz\u0119dnych kartezja\u0144skich x, y, z, okre\u015blaj\u0105cych po\u0142o\u017cenie ko\u0144ca \u0142\u0105cza w przestrzeni. Orientacja \u0142\u0105cza opisywana jest za pomoc\u0105 tzw. k\u0105t\u00f3w Eulera, kt\u00f3re okre\u015blaj\u0105, jak \u0142\u0105cze powinno by\u0107 obr\u00f3cone wok\u00f3\u0142 trzech osi: x, y, z.\n\nDla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego istniej\u0105 dwa rodzaje ruch\u00f3w: ruch translacyjny oraz ruch obrotowy.\n\nW ruchu translacyjnym \u0142\u0105cze porusza si\u0119 wzd\u0142u\u017c jednej z osi kartezja\u0144skich, przy czym orientacja \u0142\u0105cza pozostaje niezmieniona. Przyk\u0142adowo, je\u015bli \u0142\u0105cze przesuwa si\u0119 wzd\u0142u\u017c osi x, to wsp\u00f3\u0142rz\u0119dna x zmienia si\u0119, a pozosta\u0142e wsp\u00f3\u0142rz\u0119dne i k\u0105ty Eulera pozostaj\u0105 sta\u0142e.\n\nW ruchu obrotowym \u0142\u0105cze obraca si\u0119 wok\u00f3\u0142 jednej z osi, zmieniaj\u0105c jednocze\u015bnie swoj\u0105 orientacj\u0119. Przyk\u0142adowo, je\u015bli \u0142\u0105cze obraca si\u0119 wok\u00f3\u0142 osi x, to zmieni si\u0119 warto\u015b\u0107 jednego z k\u0105t\u00f3w Eulera, a pozosta\u0142e wsp\u00f3\u0142rz\u0119dne i k\u0105ty pozostan\u0105 sta\u0142e.\n\nAby manipulator m\u00f3g\u0142 porusza\u0107 si\u0119 po okre\u015blonym torze ruchu, nale\u017cy zaplanowa\u0107 sekwencj\u0119 ruch\u00f3w. Mo\u017cna to zrobi\u0107 za pomoc\u0105 trzech metod: ruchu prostoliniowego, interpolacji linowej i interpolacji spline\u2019\u00f3w.\n\nW ruchu prostoliniowym manipulator przesuwa si\u0119 po linii prostej, \u0142\u0105cz\u0105cej pocz\u0105tkow\u0105 i ko\u0144cow\u0105 pozycj\u0119. W tym przypadku nale\u017cy okre\u015bli\u0107 punkty startowy i ko\u0144cowy oraz pr\u0119dko\u015b\u0107 ruchu.\n\nInterpolacja linowa polega na interpolowaniu liniowo pomi\u0119dzy dwoma punktami ruchu, przy czym okre\u015bla si\u0119 pr\u0119dko\u015b\u0107 manipulatora w punkcie pocz\u0105tkowym i ko\u0144cowym.\n\nInterpolacja spline\u2019\u00f3w polega na interpolowaniu mi\u0119dzy punktami z u\u017cyciem krzywych spline\u2019\u00f3w. W tym przypadku manipulator porusza si\u0119 po krzywej, przy czym okre\u015bla si\u0119 kszta\u0142t spline\u2019\u00f3w oraz pr\u0119dko\u015b\u0107 ruchu.\n\nWszystkie te metody pozwalaj\u0105 na zaplanowanie ruchu manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego. Jednak\u017ce, w celu wykonania zadania, konieczne jest okre\u015blenie celu ruchu oraz trajektorii, kt\u00f3r\u0105 manipulator powinien przeby\u0107, co zale\u017cy od konkretnego zadania."
      }
    ],
    "#n": 43
  },
  "## Plik. 44": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij zastosowanie Supervisor-a w oprogramowaniu Webots. Poka\u017c jak i jakie instrukcje s\u0142u\u017c\u0105 do odczytywania": "i kontrolowania Supervisor-a w Webots.\n\nSupervisor w oprogramowaniu Webots jest g\u0142\u00f3wnym kontrolerem symulacji, kt\u00f3ry zarz\u0105dza \u015brodowiskiem symulacji oraz interakcjami pomi\u0119dzy r\u00f3\u017cnymi obiektami w symulacji. Supervisor umo\u017cliwia r\u00f3wnie\u017c komunikacj\u0119 z zewn\u0119trznymi programami, dzi\u0119ki czemu mo\u017cna zintegrowa\u0107 symulacj\u0119 z innymi systemami.\n\nInstrukcje do odczytywania i kontrolowania Supervisor-a w Webots zale\u017c\u0105 od j\u0119zyka programowania, w kt\u00f3rym piszemy kod kontrolera. Przyk\u0142adowo, w j\u0119zyku Python mo\u017cemy u\u017cy\u0107 nast\u0119puj\u0105cych instrukcji:\n\n1. Supervisor.getTime() - zwraca aktualny czas symulacji.\n2. Supervisor.setLabel(1, 'Hello world!') - umieszcza etykiet\u0119 \"Hello world!\" na pierwszym obiekcie w symulacji.\n3. node = Supervisor.getFromDef('ROBOT') - pobiera obiekt o nazwie \"ROBOT\".\n4. node.getField('translation').setSFVec3f([1, 0, 0]) - ustawia warto\u015b\u0107 pola \"translation\" obiektu na [1, 0, 0].\n\nPowy\u017csze instrukcje ilustruj\u0105 kilka sposob\u00f3w, w jakie mo\u017cna odczytywa\u0107 i kontrolowa\u0107 Supervisor-a w Webots. Mo\u017cna u\u017cy\u0107 ich do tworzenia kontroler\u00f3w robot\u00f3w, detekcji kolizji, zarz\u0105dzania \u015bwiat\u0142ami i wiele innych zada\u0144."
      },
      {
        "Zad. 2 Wyja\u015bnij spos\u00f3b dzia\u0142ania silnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, oraz w trybie z pe\u0142nym": "krokiem i dwoma fazami aktywnymi.\n\nSilnika krokowego w trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105:\n\nW trybie z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, silnik krokowy dzia\u0142a na zasadzie przemieszczania si\u0119 zatrzask\u00f3w magnetycznych mi\u0119dzy dwoma cewkami. Jeden obieg silnika sk\u0142ada si\u0119 z czterech krok\u00f3w, co oznacza, \u017ce przy ka\u017cdym kroku nast\u0119puje obr\u00f3t wa\u0142u silnika o k\u0105t 90 stopni.\n\nFaza aktywna wskazuje na to, kt\u00f3r\u0105 z cewek nale\u017cy w danym momencie zasili\u0107. W przypadku trybu z pe\u0142nym krokiem i jedn\u0105 faz\u0105 aktywn\u0105, zasila si\u0119 jedn\u0105 z cewek, a drug\u0105 pozostawia si\u0119 bez zasilania.\n\nPierwszy krok: Zasilenie pierwszej cewki powoduje obr\u00f3t wa\u0142u silnika o 90 stopni w kierunku zgodnym z ruchem wskaz\u00f3wek zegara.\n\nDrugi krok: Od\u0142\u0105czenie zasilania z pierwszej cewki, a nast\u0119pnie zasilenie drugiej cewki, powoduje obr\u00f3t wa\u0142u silnika o kolejne 90 stopni.\n\nTrzeci krok: Od\u0142\u0105czenie zasilania z drugiej cewki, a nast\u0119pnie zasilenie pierwszej cewki z przeciwn\u0105 polaryzacj\u0105, powoduje obr\u00f3t wa\u0142u silnika o kolejne 90 stopni.\n\nCzwarty krok: Od\u0142\u0105czenie zasilania z pierwszej cewki z przeciwn\u0105 polaryzacj\u0105, a nast\u0119pnie zasilenie drugiej cewki z przeciwn\u0105 polaryzacj\u0105, powoduje obr\u00f3t wa\u0142u silnika o kolejne 90 stopni.\n\nSilnika krokowego w trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi:\n\nW trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi, ka\u017cdy obieg silnika sk\u0142ada si\u0119 z o\u015bmiu krok\u00f3w, co oznacza, \u017ce przy ka\u017cdym kroku nast\u0119puje obr\u00f3t wa\u0142u o k\u0105t 45 stopni.\n\nW przypadku trybu z pe\u0142nym krokiem i dwoma fazami aktywnymi, zasilane s\u0105 dwie cewki na przemian, co powoduje zwi\u0119kszenie k\u0105ta obrotu przy ka\u017cdym kroku.\n\nPodczas pracy silnika w trybie z pe\u0142nym krokiem i dwoma fazami aktywnymi, krok kolejny jest realizowany przez zasilanie kolejnych cewek w cyklu AB-BC-CD-DA.\n\nPierwszy krok: Zasilenie cewki A powoduje obr\u00f3t wa\u0142u silnika o 45 stopni w kierunku zgodnym z ruchem wskaz\u00f3wek zegara.\n\nDrugi krok: Zasilenie cewki B powoduje obr\u00f3t wa\u0142u silnika o kolejne 45 stopni.\n\nTrzeci krok: Zasilenie cewki C powoduje obr\u00f3t wa\u0142u silnika o kolejne 45 stopni.\n\nCzwarty krok: Zasilenie cewki D powoduje obr\u00f3t wa\u0142u silnika o kolejne 45 stopni.\n\nKolejne kroki s\u0105 realizowane przez ci\u0105g\u0142e zasilanie dw\u00f3ch kolejnych cewek w cyklu AB-BC-CD-DA."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza obrotowego zamontowanego na bazie i po\u0142\u0105-": "czonego z jednym przegubem obrotowym w ko\u0144cu.\n\nParametry DH dla manipulatora:\n\n1. Tworzenie osi z\n\n- z1 - obr\u00f3t wok\u00f3\u0142 osi z, punkt A do punktu B, prostok\u0105tny do osi x\n- z2 - obr\u00f3t wok\u00f3\u0142 osi z, punkt B do punktu C, prostok\u0105tny do osi x\n\n2. Tworzenie osi x\n\n- x0 - punkt C do D, prostok\u0105tny do p\u0142aszczyzny xy\n- x1 - punkt B do punktu C, nachylony o k\u0105t 90\u00b0 w kierunku osi z\n- x2 - punkt A do punktu B, prostok\u0105tny do osi z\n\n3. D\u0142ugo\u015bci ogniw\n\n- d1 - odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 z1 a z2\n- a1 - odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 x0 a x1\n- a2 - odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 x1 a x2\n\n4. K\u0105ty przegub\u00f3w\n\n- \u03b81 - obr\u00f3t wok\u00f3\u0142 osi z1\n- \u03b82 - obr\u00f3t wok\u00f3\u0142 osi z2\n\nParametry DH:\n- d1 = 0\n- a1 = 0\n- a2 = l1\n- \u03b81 = 0\n- \u03b82 = \u03b8\n\nGdzie l1 to d\u0142ugo\u015b\u0107 \u0142\u0105cza, a \u03b8 to k\u0105t obrotu drugiego przegubu."
      }
    ],
    "#n": 44
  },
  "## Plik. 45": {
    "q&a": [
      {
        "Zad. 1 Wyja\u015bnij poj\u0119cie przekszta\u0142ce\u0144 jednorodnych.": "Przekszta\u0142cenia jednorodne to takie przekszta\u0142cenia geometryczne, kt\u00f3re zachowuj\u0105 proporcjonalne relacje mi\u0119dzy wielko\u015bciami. Innymi s\u0142owy, je\u015bli dana figura zostanie przemno\u017cona przez pewn\u0105 sta\u0142\u0105, to wszystkie jej wymiary zostan\u0105 pomno\u017cone przez t\u0119 sam\u0105 sta\u0142\u0105. Przyk\u0142adowo, gdy mamy tr\u00f3jk\u0105t o podstawie 3 cm i wysoko\u015bci 4 cm, przemno\u017cenie go przez 2 da nam tr\u00f3jk\u0105t o podstawie 6 cm i wysoko\u015bci 8 cm. Przekszta\u0142cenia jednorodne s\u0105 przydatne w matematyce, fizyce i innych naukach, gdzie stosuje si\u0119 je do opisu skali i proporcji wielko\u015bci w r\u00f3\u017cnych kontekstach."
      },
      {
        "Zad. 2 Wyja\u015bnij zjawiska zachodz\u0105ce w z\u0142\u0105czu P-N.": "Z\u0142\u0105cze P-N jest z\u0142\u0105czem pomi\u0119dzy dwoma p\u00f3\u0142przewodnikami o r\u00f3\u017cnych typach przewodnictwa: z jednej strony p\u00f3\u0142przewodnikiem typu P (zdominowanym przez domieszk\u0119 akceptorow\u0105), a z drugiej strony p\u00f3\u0142przewodnikiem typu N (z domieszk\u0105 donorow\u0105). \n\nPodczas \u0142\u0105czenia tych dw\u00f3ch p\u00f3\u0142przewodnik\u00f3w dochodzi do migracji no\u015bnik\u00f3w \u0142adunku z jednego do drugiego materia\u0142u. Elektrony z p\u00f3\u0142przewodnika N migruj\u0105 do p\u00f3\u0142przewodnika P, gdzie reaguj\u0105 z wolnymi \"dziurami\" (brakuj\u0105cymi elektronami) uwi\u0119zionanymi w domieszce akceptorowej. W wyniku reakcji elektron\u00f3w i dziur powstaj\u0105 powi\u0105zania kowalencyjne mi\u0119dzy atomami p\u00f3\u0142przewodnika, co skutkuje utworzeniem obszaru o zubo\u017conej domieszce (region zaporowy).\n\nRegion ten powoduje, \u017ce z\u0142\u0105cze P-N staje si\u0119 diod\u0105 p\u00f3\u0142przewodnikow\u0105. Podczas przep\u0142ywu pr\u0105du przez diod\u0119, elektrony przep\u0142ywaj\u0105 z obszaru N do P, a dziury z obszaru P do N, ale nie mog\u0105 one przeskoczy\u0107 na przeciwn\u0105 stron\u0119, poniewa\u017c napotykaj\u0105 barier\u0119 w postaci zubo\u017conej strefy. W ten spos\u00f3b z\u0142\u0105cze P-N przewodzi pr\u0105d tylko w jednym kierunku, a w drugim pe\u0142ni funkcj\u0119 izolatora. \n\nPod wp\u0142ywem polaryzacji zewn\u0119trznej, np. przy pod\u0142\u0105czeniu zewn\u0119trznej baterii, w obszarze P (polaryzacja dodatnia) elektrony zdominowane przez wi\u0119ksz\u0105 ilo\u015b\u0107 \"dziur\" zaczynaj\u0105 przesuwa\u0107 si\u0119 ku z\u0142\u0105czu. Jednocze\u015bnie w obszarze N (polaryzacja ujemna) elektrony zaczynaj\u0105 przesuwa\u0107 ku z\u0142\u0105czu i reaguj\u0105 z dziurami w domieszce akceptorowej. W wyniku tych proces\u00f3w z\u0119by zwi\u0119ksza si\u0119 szeroko\u015b\u0107 zubo\u017conej strefy, a w konsekwencji zwi\u0119ksza si\u0119 op\u00f3r diody. \n\nZjawiska zachodz\u0105ce w z\u0142\u0105czu P-N maj\u0105 wiele zastosowa\u0144 w elektronice i s\u0105 podstaw\u0105 funkcjonowania wielu element\u00f3w, takich jak diody, tranzystory czy fotodiody."
      },
      {
        "Zad. 3 Wyznacz parametry DH dla manipulatora z\u0142o\u017conego z jednego \u0142\u0105cza pryzmatycznego zamontowanego na bazie i": "ze stawem obrotowym na ko\u0144cu \u0142\u0105cza.\n\nParametry DH definiuj\u0105 zale\u017cno\u015bci geometryczne i kinematyczne pomi\u0119dzy kolejnymi ogniskami manipulatora. Aby wyznaczy\u0107 parametry DH dla takiego manipulatora, nale\u017cy:\n\n1. Zdefiniowa\u0107 uk\u0142ad odniesienia: Na rysunku poni\u017cej zaznaczono uk\u0142ad odniesienia, w kt\u00f3rym rozwa\u017cany b\u0119dzie manipulator. Uk\u0142ad ten ma jednostkowe wektory wzd\u0142u\u017c osi x, y i z, kt\u00f3re odpowiadaj\u0105 kolejno kierunkowi bazy, pierwszemu \u0142\u0105czu i ko\u0144cowemu stawowi obrotowemu. Wyznaczamy r\u00f3wnie\u017c \u015brodek masy i d\u0142ugo\u015b\u0107 \u0142\u0105cza pryzmatycznego.\n\n![manipulator_prismatyczny.png](https://drive.google.com/uc?id=1yCvK4L4JQXxpIwnx0WZJ828HYRykchYC)\n\n2. Podzieli\u0107 manipulator na segmenty:\nW tym przypadku manipulator sk\u0142ada si\u0119 tylko z jednego segmentu - \u0142\u0105cza pryzmatycznego.\n\n3. Dla ka\u017cdego segmentu zdefiniowa\u0107 parametry DH:  \n\nW przypadku \u0142\u0105cza pryzmatycznego, zdefiniujemy jedn\u0105 par\u0119 parametr\u00f3w DH:\n\n- $\\theta_i$ - k\u0105t mi\u0119dzy osi\u0105 $Z_i$ a osi\u0105 $Z_{i-1}$ - w tym przypadku $\\theta_1 = 0$ ze wzgl\u0119du na po\u0142o\u017cenie bazy\n- $d_i$ - odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 $Z_{i-1}$ a osi\u0105 $Z_i$ - tutaj $d_1$ b\u0119dzie r\u00f3wne d\u0142ugo\u015bci \u0142\u0105cza pryzmatycznego\n- $a_i$ - odleg\u0142o\u015b\u0107 mi\u0119dzy osi\u0105 $X_{i-1}$ a osi\u0105 $X_i$ - w tym przypadku $a_1 = 0$ poniewa\u017c osie $X_0$ i $X_1$ nachodz\u0105 na siebie\n- $\\alpha_i$ - k\u0105t mi\u0119dzy osi\u0105 $X_{i-1}$ a osi\u0105 $X_i$ - tutaj $\\alpha_1 = \\pi/2$ poniewa\u017c o\u015b $X_1$ jest prostopad\u0142a do osi $Z_0$ i kieruje si\u0119 w stron\u0119 osi $X_0$\n\nOstatecznie, parametry DH dla manipulatora sk\u0142adaj\u0105cego si\u0119 z jednego \u0142\u0105cza pryzmatycznego wygl\u0105daj\u0105 nast\u0119puj\u0105co:\n$\\theta_1 = 0$\n$d_1 = l$\n$a_1 = 0$\n$\\alpha_1 = \\pi/2$,\n\ngdzie $l$ to d\u0142ugo\u015b\u0107 \u0142\u0105cza pryzmatycznego."
      }
    ],
    "#n": 45
  }
}
